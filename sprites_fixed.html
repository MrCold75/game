<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jump Ultimate Stars - SPRITES FIXES</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        canvas {
            border: 3px solid #4a90e2;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
        }
        
        #controls, #gameInfo {
            margin: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 1px solid #4a90e2;
        }
        
        #loading {
            color: cyan;
            font-size: 18px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="loading">‚è≥ Chargement des sprites...</div>
        <canvas id="gameCanvas" width="1200" height="800" style="display: none;"></canvas>
        
        <div id="controls" style="display: none;">
            <strong>‚öîÔ∏è FIGHTING GAME - S√âLECTION DE PERSONNAGE</strong><br>
            <span style="color: gold;">ü•∑ Ninja (P1):</span> A/D=Marche | Q=Dash‚¨ÖÔ∏è | E=Dash‚û°Ô∏è | ,=Saut | S=Garde | <span style="color: lime;">I=Attaque</span> | J=Uppercut | K=Attaque basse | Z=Sp√©cial | <span style="color: orange;">O=GATLING</span> | <span style="color: cyan;">C=Technique</span><br>
            <span style="color: silver;">‚öîÔ∏è Warrior (P1):</span> A/D=Marche | Q=Dash‚¨ÖÔ∏è | E=Dash‚û°Ô∏è | ,=Saut | S=Garde | <span style="color: orange;">I=COMBO 3-HIT</span> | J=Uppercut | K=Attaque basse | Z=Sp√©cial | O=Gatling | C=Technique<br>
            <span style="color: red;">üëπ D√©mon (P2):</span> Fl√®ches=Mouvement | ‚Üì=Garde | 0=Dash‚¨ÖÔ∏è | Enter=Dash‚û°Ô∏è | L=Attaque | Numpad1/2/3=Combos<br>
            <span style="color: cyan;">üî• SP√âCIAUX:</span> <span style="color: lime;">Ninja I=Attaque normale</span> | <span style="color: orange;">Warrior I=COMBO 3-HIT (9 frames)</span> | <span style="color: red;">O=GATLING pour tous</span><br>
            <span style="color: purple;">üí™ ENDURANCE:</span> <span style="color: yellow;">Dash=25pts | Gatling=20pts/sec | Combo=15pts | R√©g√©n√®re apr√®s 1s</span><br>
            <span style="color: yellow;">‚ú® S√âLECTION:</span> <span style="color: cyan;">B/N=Confirmer personnage</span> | <span style="color: lime;">R: Red√©marrer | P: Pause</span>
        </div>
        
        <div id="gameInfo" style="display: none;">
            <div>üîã Sant√© P1: <span id="p1Health">100</span>%</div>
            <div>üîã Sant√© P2: <span id="p2Health">100</span>%</div>
            <div>üí™ Endurance P1: <span id="p1Stamina">100</span>%</div>
            <div>üí™ Endurance P2: <span id="p2Stamina">100</span>%</div>
            <div>‚ö° Phase: <span id="specialPhase">Normal</span></div>
        </div>
    </div>

    <script>
        // Variables globales
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameRunning = false;
        let keys = {};
        let players = [];
        let projectiles = [];
        let timeScale = 1.0;
        let impactEffects = [];
        let time = 0; // Pour les animations du dojo (brouillard, etc.)
        
        // üéÆ SYST√àME DE JEUX STATES
        let gameState = 'characterSelect'; // 'characterSelect', 'fighting'
        
        // ü•ä √âCRAN DE S√âLECTION DE PERSONNAGES - 2 FIGHTERS
        let characterSelect = {
            player1Selection: 0, // Index du personnage s√©lectionn√© P1 (0=Ninja)
            player2Selection: 1, // Index du personnage s√©lectionn√© P2 (1=Warrior)
            player1Confirmed: false,
            player2Confirmed: false,
            animationTimer: 0,
            characters: [
                {
                    name: 'Ninja',
                    type: 'ninja', 
                    description: 'Rapide et agile',
                    stats: { speed: 5, power: 3, defense: 3 }
                },
                {
                    name: 'Warrior',
                    type: 'warrior', 
                    description: 'Puissant et r√©sistant',
                    stats: { speed: 2, power: 5, defense: 5 }
                }
            ]
        };
        
        // ‚ú® SYST√àME DE PARTICULES DYNAMIQUES
        let particles = []; // Tableau pour particules style Tekken
        
        // üé¨ SYST√àME DE CAM√âRA DYNAMIQUE
        let camera = {
            x: 0,
            y: 0,
            scale: 1.0,
            targetScale: 1.0,
            shakeX: 0,
            shakeY: 0,
            shakeIntensity: 0,
            isSpecialCamera: false,
            specialProgress: 0,
            targetPlayer: null,
            // Cinematic zoom (Tekken-style)
            cinematicZoomEnabled: true,
            minScale: 1.0,  // Maximum zoom out (initial camera)
            maxScale: 1.6,  // Maximum zoom in when players are close
            targetX: 0,
            targetY: 0
        };
        
        // ÔøΩ SYST√àME DE FREEZE FRAMES (HITSTOP)
        let freezeFrame = {
            active: false,
            duration: 0,
            flashWhite: false,
            flashDuration: 0
        };
        
        // ÔøΩü§ñ IA SIMPLE POUR TESTS
        let aiEnabled = false;
        let aiTimer = 0;
        
        // SYST√àME DE ROUNDS PROFESSIONNEL ü•ä
        let roundSystem = {
            currentRound: 1,
            maxRounds: 5, // Premier √† 3 victoires
            p1Wins: 0,
            p2Wins: 0,
            roundInProgress: true,
            showingRoundResult: false,
            resultTimer: 0,
            resultDuration: 6000, // 6 secondes pour laisser les animations se jouer
            matchFinished: false,
            winner: null,
            roundStartTime: 0,
            roundDuration: 60000, // 60 secondes par round
            // NOUVEAU : Syst√®me d'animations de victoire/d√©faite üé≠
            showingVictoryPoses: false,
            victoryAnimationTime: 0,
            victoryAnimationDuration: 4000, // 4 secondes d'animations (plus long pour 9 frames)
            roundWinner: null, // Gagnant du round actuel
            roundLoser: null   // Perdant du round actuel
        };
        
        // Syst√®me de screen shake
        let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
        
        // Fonction pour d√©clencher le screen shake
        function startScreenShake(duration, intensity) {
            screenShake.duration = Math.max(screenShake.duration, duration);
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
        }
        
        // SYST√àME DE PR√âCHARGEMENT DES SPRITES
        const sprites = {};
        let spritesLoaded = 0;
        let totalSprites = 0;
        
        const spriteList = [
            // Sprites normaux
            'ninja_idle1.png', 'ninja_idle2.png', 'ninja_idle3.png',
            'ninja_walk1.png', 'ninja_walk2.png', 'ninja_walk3.png', 'ninja_walk4.png', 'ninja_walk5.png', 'ninja_walk6.png', 'ninja_walk7.png', 'ninja_walk8.png',
            'ninja_jump1.png', 'ninja_jump2.png', 'ninja_jump3.png', 'ninja_jump4.png', 'ninja_jump5.png',
            'ninja_attack1.png', 'ninja_attack2.png', 'ninja_attack3.png',
            // Sprites Gatling (9 frames)
            'ninja_gatling1.png', 'ninja_gatling2.png', 'ninja_gatling3.png', 'ninja_gatling4.png', 'ninja_gatling5.png',
            'ninja_gatling6.png', 'ninja_gatling7.png', 'ninja_gatling8.png', 'ninja_gatling9.png',
            'ninja_hurt1.png', 'ninja_hurt2.png',
            // Nouveaux sprites de combos
            'ninja_uppercut1.png', 'ninja_uppercut2.png', 'ninja_uppercut3.png',
            'ninja_low1.png', 'ninja_low2.png', 'ninja_low3.png',
            'ninja_double1.png', 'ninja_double2.png', 'ninja_double3.png',
            // Sprites de knockdown et relever
            'ninja_down1.png', 'ninja_down2.png', 'ninja_down3.png',
            'ninja_getup1.png', 'ninja_getup2.png', 'ninja_getup3.png', 'ninja_getup4.png',
            // Sprites de dash
            'ninja_dash1.png', 'ninja_dash2.png', 'ninja_dash3.png',
            // Sprites de shield/garde
            'ninja_shield1.png', 'ninja_shield2.png', 'ninja_shield3.png',
            // Sprites de victoire et d√©faite üéâüò¢ (9 victory, 5 defeat)
            'ninja_victory1.png', 'ninja_victory2.png', 'ninja_victory3.png', 'ninja_victory4.png', 'ninja_victory5.png',
            'ninja_victory6.png', 'ninja_victory7.png', 'ninja_victory8.png', 'ninja_victory9.png',
            'ninja_defeat1.png', 'ninja_defeat2.png', 'ninja_defeat3.png', 'ninja_defeat4.png', 'ninja_defeat5.png',
            'demon_victory1.png', 'demon_victory2.png', 'demon_victory3.png', 'demon_victory4.png', 'demon_victory5.png',
            'demon_victory6.png', 'demon_victory7.png', 'demon_victory8.png', 'demon_victory9.png',
            'demon_defeat1.png', 'demon_defeat2.png', 'demon_defeat3.png', 'demon_defeat4.png',
            // Sprites sp√©ciaux
            'assets/characters/ninja/special/ninja_special1.png', 'assets/characters/ninja/special/ninja_special2.png', 'assets/characters/ninja/special/ninja_special3.png',
            'assets/characters/ninja/special/ninja_special4.png', 'assets/characters/ninja/special/ninja_special5.png', 'assets/characters/ninja/special/ninja_special6.png',
            // Sprites uppercut, low et double
            'assets/characters/ninja/special/ninja_uppercut1.png', 'assets/characters/ninja/special/ninja_uppercut2.png', 'assets/characters/ninja/special/ninja_uppercut3.png',
            'assets/characters/ninja/special/ninja_low1.png', 'assets/characters/ninja/special/ninja_low2.png', 'assets/characters/ninja/special/ninja_low3.png',
            'assets/characters/ninja/special/ninja_double1.png', 'assets/characters/ninja/special/ninja_double2.png', 'assets/characters/ninja/special/ninja_double3.png',
            
            // üó°Ô∏è SPRITES WARRIOR - NOUVEAU SYST√àME AVEC FRAMES
            'warrior_idle1.png', 'warrior_idle2.png', 'warrior_idle3.png', 'warrior_idle4.png',
            'warrior_walk1.png', 'warrior_walk2.png', 'warrior_walk3.png', 'warrior_walk4.png',
            'warrior_walk5.png', 'warrior_walk6.png', 'warrior_walk7.png', 'warrior_walk8.png',
            'warrior_jump1.png', 'warrior_jump2.png', 'warrior_jump3.png', 'warrior_jump4.png', 'warrior_jump5.png',
            'warrior_hurt1.png', 'warrior_hurt2.png', 'warrior_hurt3.png',
            'warrior_dash1.png', 'warrior_dash2.png', 'warrior_dash3.png',
            'warrior_shield1.png', 'warrior_shield2.png', 'warrior_shield3.png',
            'warrior_defeat1.png', 'warrior_defeat2.png', 'warrior_defeat3.png', 'warrior_defeat4.png',
            'warrior_getup1.png', 'warrior_getup2.png', 'warrior_getup3.png', 'warrior_getup4.png',
            
            // ‚öîÔ∏è SPRITES WARRIOR COMBAT - COMBO 3-HIT (9 frames) - CHEMINS COMPLETS
            'warrior_combo1.png', 'warrior_combo2.png', 'warrior_combo3.png', 'warrior_combo4.png', 'warrior_combo5.png',
            'warrior_combo6.png', 'warrior_combo7.png', 'warrior_combo8.png', 'warrior_combo9.png',
            
            // ü•ä SPRITES WARRIOR ATTAQUES DE BASE
            'warrior_attack1.png', 'warrior_attack2.png', 'warrior_attack3.png', 'warrior_attack4.png',
            'warrior_uppercut1.png', 'warrior_uppercut2.png', 'warrior_uppercut3.png', 'warrior_uppercut4.png',
            'warrior_low1.png', 'warrior_low2.png', 'warrior_low3.png', 'warrior_low4.png',
            'warrior_special1.png', 'warrior_special2.png', 'warrior_special3.png', 'warrior_special4.png', 'warrior_special5.png', 'warrior_special6.png', 'warrior_special7.png'
        ];
        
        // Fonction pour obtenir le chemin correct selon la nouvelle organisation
        function getSpritePath(spriteName) {
            const [character, ...actionParts] = spriteName.split('_');
            const fullAction = actionParts.join('_'); // Rejoint au cas o√π il y aurait plusieurs underscores
            
            // Mapping des actions vers les cat√©gories
            const categoryMapping = {
                'idle': 'basic',
                'walk': 'basic', 
                'jump': 'basic',
                'icon': 'basic',
                'attack': 'combat',
                'gatling': 'combat', // Nouveau : sprites Gatling dans combat
                'combo': 'combat',   // ‚öîÔ∏è WARRIOR : sprites Combo dans combat
                'hurt': 'combat',
                'uppercut': 'special',
                'low': 'special',
                'double': 'special',
                'down': 'special',
                'getup': 'getup',     // WARRIOR : getup dans son propre dossier
                'dash': 'dash',
                'shield': 'shield',
                'victory': 'victory', // Nouvelles animations de victoire üéâ
                'defeat': 'defeat'    // Nouvelles animations de d√©faite üò¢
            };
            
            // Extraire l'action de base (sans le num√©ro)
            let baseAction = 'idle';
            for (const action in categoryMapping) {
                if (fullAction.startsWith(action)) {
                    baseAction = action;
                    break;
                }
            }
            
            const category = categoryMapping[baseAction] || 'basic';
            return `${character}/${category}/${spriteName}`;
        }

        // ‚ú® FONCTIONS UTILITAIRES POUR EFFETS AVANC√âS
        
        // üé¨ CAM√âRA DYNAMIQUE POUR ATTAQUES SP√âCIALES
        function startSpecialCamera(player) {
            camera.isSpecialCamera = true;
            camera.specialProgress = 0;
            camera.targetScale = 1.5; // Zoom avant
            camera.shakeIntensity = 15; // Screen shake intense
            camera.targetPlayer = player; // NOUVEAU : Suivre ce joueur
            timeScale = 0.3; // Slow motion
            
            console.log(`üé¨ CAM√âRA SP√âCIALE activ√©e pour ${player.type}!`);
        }
        
        function updateSpecialCamera() {
            if (!camera.isSpecialCamera) return;
            
            camera.specialProgress += 0.03; // Progression de l'effet
            
            // Zoom progressif
            camera.scale += (camera.targetScale - camera.scale) * 0.1;
            
            // NOUVEAU : Suivre le joueur qui attaque
            if (camera.targetPlayer) {
                const targetX = camera.targetPlayer.x + camera.targetPlayer.width / 2;
                const targetY = camera.targetPlayer.y + camera.targetPlayer.height / 2;
                
                // Interpolation douce vers la position du joueur
                camera.x += (targetX - canvas.width / 2 - camera.x) * 0.15;
                camera.y += (targetY - canvas.height / 2 - camera.y) * 0.15;
            }
            
            // Screen shake qui diminue
            if (camera.shakeIntensity > 0) {
                camera.shakeX = (Math.random() - 0.5) * camera.shakeIntensity;
                camera.shakeY = (Math.random() - 0.5) * camera.shakeIntensity;
                camera.shakeIntensity *= 0.95; // Diminue progressivement
            }
            
            // Fin de l'effet sp√©cial
            if (camera.specialProgress > 1.0) {
                endSpecialCamera();
            }
        }
        
        function endSpecialCamera() {
            camera.isSpecialCamera = false;
            camera.shakeIntensity = 0;
            camera.shakeX = 0;
            camera.shakeY = 0;
            camera.targetPlayer = null; // Arr√™ter de suivre
            
            // Retour √† la vitesse normale √©galement instantan√©
            timeScale = 1.0;
            
            // Don't reset scale/position - let cinematic zoom take over
            console.log(`üé¨ CAM√âRA SP√âCIALE termin√©e - Transition vers cinematic zoom!`);
        }
        
        function applyScreenShake(intensity) {
            camera.shakeIntensity = Math.max(camera.shakeIntensity, intensity);
        }
        
        // üé¨ CINEMATIC ZOOM - TEKKEN STYLE
        function updateCinematicZoom() {
            // Skip if cinematic zoom is disabled or during special camera
            if (!camera.cinematicZoomEnabled || camera.isSpecialCamera) return;
            
            // Need at least 2 players
            if (players.length < 2) return;
            
            const player1 = players[0];
            const player2 = players[1];
            
            // Calculate center point between players
            const centerX = (player1.x + player1.width / 2 + player2.x + player2.width / 2) / 2;
            const centerY = (player1.y + player1.height / 2 + player2.y + player2.height / 2) / 2;
            
            // Calculate distance between players
            const dx = (player2.x + player2.width / 2) - (player1.x + player1.width / 2);
            const dy = (player2.y + player2.height / 2) - (player1.y + player1.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Define distance thresholds (in pixels)
            const minDistance = 150;  // Very close - maximum zoom in
            const maxDistance = 600;  // Far apart - maximum zoom out (back to initial)
            
            // Calculate target scale based on distance (inverse relationship)
            let targetScale;
            if (distance <= minDistance) {
                targetScale = camera.maxScale;
            } else if (distance >= maxDistance) {
                targetScale = camera.minScale;
            } else {
                // Linear interpolation between maxScale and minScale
                const t = (distance - minDistance) / (maxDistance - minDistance);
                targetScale = camera.maxScale - (camera.maxScale - camera.minScale) * t;
            }
            
            // Update target values
            camera.targetScale = targetScale;
            camera.targetX = centerX - canvas.width / 2;
            camera.targetY = centerY - canvas.height / 2;
            
            // Smooth interpolation towards target
            const lerpSpeed = 0.05; // Adjust for smoother/faster transitions (lower = smoother)
            camera.scale += (camera.targetScale - camera.scale) * lerpSpeed;
            camera.x += (camera.targetX - camera.x) * lerpSpeed;
            camera.y += (camera.targetY - camera.y) * lerpSpeed;
        }
        
        // ü•ä SYST√àME DE FREEZE FRAMES POUR IMPACTS PUISSANTS
        function triggerFreezeFrame(duration, withFlash = false, flashDuration = 50) {
            freezeFrame.active = true;
            freezeFrame.duration = duration;
            freezeFrame.flashWhite = withFlash;
            freezeFrame.flashDuration = withFlash ? flashDuration : 0;
            
            console.log(`ü•ä FREEZE FRAME: ${duration}ms ${withFlash ? '+ Flash Blanc' : ''}`);
        }
        
        function updateFreezeFrame(deltaTime) {
            if (!freezeFrame.active) return 1.0; // Vitesse normale
            
            // D√©compter le freeze
            freezeFrame.duration -= deltaTime;
            
            // D√©compter le flash
            if (freezeFrame.flashWhite && freezeFrame.flashDuration > 0) {
                freezeFrame.flashDuration -= deltaTime;
                if (freezeFrame.flashDuration <= 0) {
                    freezeFrame.flashWhite = false;
                }
            }
            
            // Fin du freeze frame
            if (freezeFrame.duration <= 0) {
                freezeFrame.active = false;
                freezeFrame.flashWhite = false;
                console.log(`ü•ä FREEZE FRAME termin√©`);
                return 1.0;
            }
            
            return 0.0; // Arr√™t total pendant le freeze
        }
        
        function renderFreezeEffects(ctx) {
            // Flash blanc sur tout l'√©cran
            if (freezeFrame.flashWhite && freezeFrame.flashDuration > 0) {
                ctx.save();
                const alpha = Math.min(0.8, freezeFrame.flashDuration / 50); // Fade out
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                
                console.log(`‚ö° Flash blanc: alpha ${alpha.toFixed(2)}`);
            }
        }
        
        // üéµ SYST√àME AUDIO SYNTH√âTIQUE - SONS JUTEUX !
        let audioContext = null;
        let masterVolume = 0.3;
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('üéµ Audio Context initialis√© !');
            }
        }
        
        // ü•ä SONS D'IMPACT SYNTH√âTIQUES - VERSION BRUTALE !
        function playImpactSound(damage, isBlocked = false, isCritical = false) {
            if (!audioContext) return;
            
            if (isBlocked) {
                // Son m√©tallique dur pour les blocks
                playMetallicClang();
                console.log('üõ°Ô∏è CLANG m√©tallique !');
            } else if (isCritical) {
                // Son explosif brutal pour les critiques
                playExplosiveHit();
                console.log('üí• EXPLOSION !');
            } else {
                // Son de coup de poing charnu
                playMeatyPunch(damage);
                console.log(`ü•ä PUNCH charnu: ${damage} d√©g√¢ts`);
            }
        }
        
        // ü•© SON DE COUP DE POING CHARNU
        function playMeatyPunch(damage) {
            // Bruit blanc pour simuler l'impact charnu
            const bufferSize = audioContext.sampleRate * 0.1; // 100ms
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // G√©n√©rer du bruit blanc avec enveloppe
            for (let i = 0; i < bufferSize; i++) {
                const envelope = Math.exp(-i / (bufferSize * 0.3)); // Decay rapide
                data[i] = (Math.random() * 2 - 1) * envelope * 0.5;
            }
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            source.buffer = buffer;
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(300 + damage * 10, audioContext.currentTime); // Plus grave = plus de d√©g√¢ts
            
            const volume = Math.min(0.6, 0.3 + (damage * 0.01)) * masterVolume;
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            source.start();
        }
        
        // üî® SON M√âTALLIQUE POUR BLOCKS
        function playMetallicClang() {
            const oscillator1 = audioContext.createOscillator();
            const oscillator2 = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            // Deux fr√©quences pour cr√©er un son m√©tallique
            oscillator1.frequency.setValueAtTime(2000, audioContext.currentTime);
            oscillator2.frequency.setValueAtTime(2400, audioContext.currentTime);
            
            oscillator1.type = 'square';
            oscillator2.type = 'square';
            
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(1800, audioContext.currentTime);
            filter.Q.setValueAtTime(10, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.4 * masterVolume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
            
            oscillator1.connect(filter);
            oscillator2.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator1.start();
            oscillator2.start();
            oscillator1.stop(audioContext.currentTime + 0.05);
            oscillator2.stop(audioContext.currentTime + 0.05);
        }
        
        // üí• SON EXPLOSIF POUR CRITIQUES
        function playExplosiveHit() {
            // Combinaison de bruit et de basse fr√©quence
            const bufferSize = audioContext.sampleRate * 0.15;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                const envelope = Math.exp(-i / (bufferSize * 0.2));
                const noise = (Math.random() * 2 - 1) * envelope;
                const bass = Math.sin(2 * Math.PI * 60 * i / audioContext.sampleRate) * envelope;
                data[i] = (noise * 0.7 + bass * 0.8) * 0.8;
            }
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            
            source.buffer = buffer;
            gainNode.gain.setValueAtTime(0.7 * masterVolume, audioContext.currentTime);
            
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            source.start();
        }
        
        // üí® SON DE WHOOSH (coup qui rate) - VERSION COMBAT
        function playWhooshSound() {
            if (!audioContext) return;
            
            // Bruit filtr√© pour simuler l'air qui se d√©place
            const bufferSize = audioContext.sampleRate * 0.2; // 200ms
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                const progress = i / bufferSize;
                const envelope = Math.sin(progress * Math.PI); // Enveloppe en cloche
                data[i] = (Math.random() * 2 - 1) * envelope * 0.3;
            }
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            source.buffer = buffer;
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(500, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(1500, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.25 * masterVolume, audioContext.currentTime);
            
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            source.start();
            
            console.log('üí® SWOOSH de combat !');
        }
        
        // ‚ö° SON DE CHARGE SP√âCIALE - VERSION √âNERG√âTIQUE
        function playChargeSound() {
            if (!audioContext) return;
            
            // Son de mont√©e en puissance avec harmoniques
            const oscillator1 = audioContext.createOscillator();
            const oscillator2 = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            // Fr√©quence fondamentale qui monte
            oscillator1.frequency.setValueAtTime(80, audioContext.currentTime);
            oscillator1.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.6);
            
            // Harmonique pour enrichir le son
            oscillator2.frequency.setValueAtTime(120, audioContext.currentTime);
            oscillator2.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.6);
            
            oscillator1.type = 'sawtooth';
            oscillator2.type = 'triangle';
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(400, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.6);
            
            // Enveloppe qui monte et redescend
            gainNode.gain.setValueAtTime(0.05 * masterVolume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.3 * masterVolume, audioContext.currentTime + 0.4);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.6);
            
            oscillator1.connect(filter);
            oscillator2.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator1.start();
            oscillator2.start();
            oscillator1.stop(audioContext.currentTime + 0.6);
            oscillator2.stop(audioContext.currentTime + 0.6);
            
            console.log('‚ö° CHARGE √âNERG√âTIQUE !');
        }
        
        // üí• CR√âATION D'IMPACT STYLE TEKKEN
        function createImpactBurst(x, y, type = 'impact') {
            // Explosion rapide de 6-8 particules
            const count = 6 + Math.floor(Math.random() * 3);
            for (let i = 0; i < count; i++) {
                const offsetX = (Math.random() - 0.5) * 30;
                const offsetY = (Math.random() - 0.5) * 30;
                particles.push(new Particle(x + offsetX, y + offsetY, type));
            }
        }
        
        function checkWallBounce(player) {
            // Murs gauche et droite du canvas
            if (player.x <= 0 && player.vx < 0) {
                player.x = 0;
                player.vx = -player.vx * 0.7; // Rebond avec perte d'√©nergie
                player.isWallBouncing = true;
                // Particules d'√©tincelles supprim√©es
                console.log(`${player.type}: Wall bounce LEFT!`);
                return true;
            }
            
            if (player.x + player.width >= canvas.width && player.vx > 0) {
                player.x = canvas.width - player.width;
                player.vx = -player.vx * 0.7;
                player.isWallBouncing = true;
                // Particules d'√©tincelles supprim√©es
                console.log(`${player.type}: Wall bounce RIGHT!`);
                return true;
            }
            
            return false;
        }

        function createFallbackSprite(spriteName) {
            const canvas = document.createElement('canvas');
            canvas.width = 80;
            canvas.height = 80;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(0, 0, 80, 80);
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(spriteName.split('_')[1] || 'SPRITE', 40, 35);
            ctx.fillText(spriteName.split('_')[2] || '', 40, 50);
            return canvas;
        }
        
        function preloadSprites() {
            totalSprites = spriteList.length;
            document.getElementById('loading').textContent = `‚è≥ Chargement des sprites... (0/${totalSprites})`;
            
            console.log(`üöÄ D√©but chargement de ${totalSprites} sprites`);
            
            // Timeout de s√©curit√© - d√©marrer le jeu apr√®s 10 secondes m√™me si pas tout charg√©
            setTimeout(() => {
                if (spritesLoaded < totalSprites) {
                    console.warn(`‚è∞ Timeout atteint. D√©marrage avec ${spritesLoaded}/${totalSprites} sprites charg√©s`);
                    // Cr√©er des fallbacks pour les sprites manquants
                    spriteList.forEach(spritePath => {
                        if (!sprites[spritePath]) {
                            sprites[spritePath] = createFallbackSprite(spritePath);
                        }
                    });
                    startGame();
                }
            }, 10000);
            
            spriteList.forEach(spritePath => {
                const img = new Image();
                let fullPath;
                
                // Si le chemin commence d√©j√† par assets/, on l'utilise tel quel
                if (spritePath.startsWith('assets/')) {
                    fullPath = spritePath;
                } else if (spritePath.startsWith('skills/')) {
                    fullPath = `assets/characters/${spritePath}`;
                } else {
                    fullPath = `assets/characters/${getSpritePath(spritePath)}`;
                }
                
                // Debug pour les sprites sp√©ciaux
                if (spritePath.startsWith('skills/')) {
                    console.log(`üîß SKILLS sprite: ${spritePath} ‚Üí ${fullPath}`);
                }
                
                // Debug pour combo sprites
                if (spritePath.startsWith('combat/')) {
                    console.log(`‚öîÔ∏è COMBO sprite: ${spritePath} ‚Üí ${fullPath}`);
                }
                
                // Debug pour dash et shield
                if (spritePath.includes('dash') || spritePath.includes('shield')) {
                    console.log(`üìÇ Loading sprite: ${spritePath} ‚Üí ${fullPath}`);
                }
                
                img.onload = () => {
                    sprites[spritePath] = img;
                    spritesLoaded++;
                    if (spritePath.includes('ninja_special')) {
                        console.log(`‚úÖ NINJA SPECIAL sprite charg√©: ${spritePath} ‚Üí ${fullPath}`);
                    }
                    console.log(`‚úÖ Sprite charg√©: ${spritePath}`);
                    document.getElementById('loading').textContent = `‚è≥ Chargement des sprites... (${spritesLoaded}/${totalSprites})`;
                    
                    if (spritesLoaded === totalSprites) {
                        startGame();
                    }
                };
                
                img.onerror = () => {
                    console.error(`‚ùå ERREUR: Sprite non trouv√©: ${fullPath}`);
                    // Utiliser le sprite de fallback
                    sprites[spritePath] = createFallbackSprite(spritePath);
                    spritesLoaded++;
                    console.log(`‚ö†Ô∏è Sprite fallback cr√©√© pour: ${spritePath}`);
                    document.getElementById('loading').textContent = `‚è≥ Chargement des sprites... (${spritesLoaded}/${totalSprites})`;
                    
                    if (spritesLoaded === totalSprites) {
                        startGame();
                    }
                    sprites[spritePath] = null;
                    spritesLoaded++;
                    document.getElementById('loading').textContent = `‚è≥ Chargement des sprites... (${spritesLoaded}/${totalSprites})`;
                    
                    if (spritesLoaded === totalSprites) {
                        startGame();
                    }
                };
                
                // üîÑ ANTI-CACHE POUR EDGE - Ajout timestamp
                const timestamp = Date.now();
                img.src = fullPath + '?' + timestamp;
            });
        }
        
        function startGame() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('gameInfo').style.display = 'block';
            
            console.log(`üéÆ Jeu d√©marr√© avec ${spritesLoaded} sprites charg√©s`);
            gameRunning = true;
            init();
        }
        
        function getSprite(animationState, frame, characterType = 'ninja') {
            let spritePath;
            
            // üó°Ô∏è SUPPORT MULTI-PERSONNAGES !
            const characterPrefix = characterType.toLowerCase() === 'warrior' ? 'warrior' : 'ninja';
            const characterFolder = characterType.toLowerCase() === 'warrior' ? 'warrior' : 'ninja';
            
            // FORCE ABSOLUE : Si c'est special, on utilise VOS sprites !
            if (animationState === 'special') {
                spritePath = `assets/characters/${characterFolder}/special/${characterPrefix}_special${frame}.png`;
                return sprites[spritePath] || sprites[`assets/characters/${characterFolder}/special/${characterPrefix}_special1.png`];
            }
            
            // Gestion des nouveaux √©tats de combo
            if (animationState === 'uppercut') {
                spritePath = `assets/characters/${characterFolder}/special/${characterPrefix}_uppercut${frame}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `assets/characters/${characterFolder}/special/${characterPrefix}_uppercut1.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'low') {
                spritePath = `assets/characters/${characterFolder}/special/${characterPrefix}_low${frame}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `assets/characters/${characterFolder}/special/${characterPrefix}_low1.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'double') {
                spritePath = `assets/characters/${characterFolder}/special/${characterPrefix}_double${frame}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `assets/characters/${characterFolder}/special/${characterPrefix}_double1.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'down') {
                // Animation de chute au sol (3 frames)
                spritePath = `${characterPrefix}_down${Math.min(frame, 3)}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `${characterPrefix}_hurt${Math.min(frame, 2)}.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'getup') {
                // Animation de r√©cup√©ration (4 frames)
                spritePath = `${characterPrefix}_getup${Math.min(frame, 4)}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `${characterPrefix}_hurt${Math.min(frame, 2)}.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'gatling') {
                // Nouveau syst√®me Gatling 9 frames - PRIORIT√â ABSOLUE
                const gatlingFrame = Math.min(Math.max(frame, 1), 9);
                spritePath = `${characterPrefix}_gatling${gatlingFrame}.png`;
                console.log(`üéØ GATLING: Frame ${gatlingFrame}, Sprite: ${spritePath}, Exists: ${!!sprites[spritePath]}`);
                return sprites[spritePath] || null;
            } else if (animationState === 'combo') {
                // ‚öîÔ∏è SYST√àME WARRIOR COMBO 9 frames - UTILISE getSpritePath
                const comboFrame = Math.min(Math.max(frame, 1), 9);
                spritePath = `${characterPrefix}_combo${comboFrame}.png`;
                console.log(`‚öîÔ∏è COMBO: Frame ${comboFrame}, Sprite: ${spritePath}, Exists: ${!!sprites[spritePath]}`);
                return sprites[spritePath] || null;
            } else if (animationState === 'dash') {
                // Pour le dash, utiliser toujours le sprite normal (pas de retournement automatique)
                spritePath = `${characterPrefix}_dash${frame}.png`;
            } else if (animationState === 'shield') {
                // Pour le shield, utiliser toujours la frame 2 (fixe)
                spritePath = `${characterPrefix}_shield2.png`;
            } else {
                spritePath = `${characterPrefix}_${animationState}${frame}.png`;
            }
            
            // Debug pour walk et jump
            if (animationState === 'walk' || animationState === 'jump' || animationState === 'dash' || animationState === 'shield') {
                console.log(`üéØ ${characterType.toUpperCase()}: ${animationState} frame ${frame} -> ${spritePath}, exists: ${!!sprites[spritePath]}`);
            }
            
            return sprites[spritePath] || null;
        }

        // Classe pour les effets visuels d'impact
        class ImpactEffect {
            constructor(x, y, type, duration = 300) {
                this.x = x;
                this.y = y;
                this.type = type; // 'hit', 'critical', 'knockdown'
                this.duration = duration;
                this.timer = duration;
                this.size = 0;
                this.maxSize = type === 'knockdown' ? 80 : type === 'critical' ? 60 : 40;
                this.alpha = 1.0;
                this.particles = [];
                
                // Cr√©er des particules pour l'effet
                const particleCount = type === 'knockdown' ? 12 : type === 'critical' ? 8 : 5;
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: 0,
                        y: 0,
                        vx: (Math.random() - 0.5) * 200,
                        vy: (Math.random() - 0.5) * 200,
                        life: 1.0,
                        size: Math.random() * 6 + 2
                    });
                }
            }
            
            update(deltaTime) {
                this.timer -= deltaTime * 1000;
                const progress = 1 - (this.timer / this.duration);
                
                // Animation de taille (expansion puis contraction)
                if (progress < 0.3) {
                    this.size = (progress / 0.3) * this.maxSize;
                } else {
                    this.size = this.maxSize * (1 - (progress - 0.3) / 0.7);
                }
                
                this.alpha = Math.max(0, 1 - progress);
                
                // Mettre √† jour les particules
                this.particles.forEach(p => {
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    p.life -= deltaTime * 2; // Dur√©e de vie des particules
                });
                
                return this.timer > 0;
            }
            
            render(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                
                // Effet principal selon le type
                ctx.translate(this.x, this.y);
                
                if (this.type === 'knockdown') {
                    // Effet rouge intense pour knockdown
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, 'rgba(255, 50, 50, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 100, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 150, 150, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    
                    // Lignes d'impact
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * this.size * 0.8, Math.sin(angle) * this.size * 0.8);
                        ctx.stroke();
                    }
                } else if (this.type === 'critical') {
                    // Effet jaune pour coup critique
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, 'rgba(255, 255, 50, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 150, 50, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                } else if (this.type === 'special_explosion') {
                    // Effet SPECTACULAIRE pour attaque sp√©ciale ninja !
                    const progress = 1 - (this.timer / this.duration);
                    
                    // Explosion principale avec d√©grad√© arc-en-ciel
                    const gradient1 = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient1.addColorStop(0, 'rgba(255, 255, 255, 1.0)'); // Centre blanc pur
                    gradient1.addColorStop(0.2, 'rgba(255, 100, 255, 0.9)'); // Magenta intense
                    gradient1.addColorStop(0.4, 'rgba(100, 255, 255, 0.7)'); // Cyan brillant
                    gradient1.addColorStop(0.6, 'rgba(255, 255, 100, 0.5)'); // Jaune √©lectrique
                    gradient1.addColorStop(0.8, 'rgba(255, 100, 100, 0.3)'); // Rouge √©nerg√©tique
                    gradient1.addColorStop(1, 'rgba(100, 100, 255, 0)'); // Bleu qui dispara√Æt
                    ctx.fillStyle = gradient1;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    
                    // Cercles d'√©nergie pulsants
                    for (let i = 0; i < 4; i++) {
                        const ringSize = this.size * (0.3 + i * 0.2) * (1 + Math.sin(progress * Math.PI * 4 + i) * 0.1);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 - i * 0.15})`;
                        ctx.lineWidth = 4 - i;
                        ctx.beginPath();
                        ctx.arc(0, 0, ringSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Rayons d'√©nergie rotatifs
                    for (let i = 0; i < 16; i++) {
                        const angle = (i / 16) * Math.PI * 2 + progress * Math.PI * 2;
                        const length = this.size * (0.8 + Math.sin(progress * Math.PI * 8 + i) * 0.2);
                        ctx.strokeStyle = `rgba(255, ${200 + Math.sin(angle) * 55}, 255, ${0.7 - (i % 4) * 0.1})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * length, Math.sin(angle) * length);
                        ctx.stroke();
                    }
                } else if (this.type === 'blocked') {
                    // Effet cyan pour attaque bloqu√©e
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(100, 255, 255, 0.4)');
                    gradient.addColorStop(1, 'rgba(150, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    
                    // Effet de bouclier
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.9)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Effet bleu pour coup normal
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, 'rgba(100, 150, 255, 0.6)');
                    gradient.addColorStop(0.5, 'rgba(150, 200, 255, 0.3)');
                    gradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                }
                
                // Rendre les particules
                this.particles.forEach(p => {
                    if (p.life > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${p.life})`;
                        ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                    }
                });
                
                ctx.restore();
            }
        }

        // Classe Projectile
        class FixedProjectile {
            constructor(x, y, direction, owner) {
                this.x = x;
                this.y = y + 30;
                this.width = 80;  // Plus grand pour vos nouveaux sprites !
                this.height = 40; // Plus grand pour vos nouveaux sprites !
                this.direction = direction;
                this.speed = 500;
                this.damage = 40;
                this.owner = owner;
                this.timer = 0;
                this.life = 3000;
                this.glowIntensity = 1.0;
                this.trail = []; // Tableau pour stocker les positions de la tra√Æn√©e
                this.trailMaxLength = 20; // Tra√Æn√©e MEGA spectaculaire !
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000;
                
                // Ajouter la position actuelle √† la tra√Æn√©e
                this.trail.push({
                    x: this.x + this.width / 2,  // Centre du projectile
                    y: this.y + this.height / 2,
                    alpha: 1.0  // Transparence initiale
                });
                
                // Limiter la longueur de la tra√Æn√©e
                if (this.trail.length > this.trailMaxLength) {
                    this.trail.shift();  // Supprimer le plus ancien
                }
                
                // Diminuer la transparence des anciennes positions
                for (let i = 0; i < this.trail.length; i++) {
                    this.trail[i].alpha = (i + 1) / this.trail.length;
                }
                
                this.x += this.speed * this.direction * dt;
                this.timer += deltaTime;
                this.glowIntensity = 0.5 + 0.5 * Math.sin(this.timer * 0.01);
                
                return !(this.x < -100 || this.x > 1300 || this.timer > this.life);
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            render(ctx) {
                // === TRA√éN√âE SPECTACULAIRE === (derri√®re le projectile)
                ctx.save();
                for (let i = 0; i < this.trail.length - 1; i++) {
                    const current = this.trail[i];
                    const progress = current.alpha;
                    
                    // Taille variable de la tra√Æn√©e (plus grosse au d√©but)
                    const size = (progress * 25) + 8;
                    const alpha = progress * 0.8;
                    
                    // Effet de double cercle pour plus de profondeur
                    ctx.globalAlpha = alpha;
                    
                    // Cercle ext√©rieur (halo)
                    ctx.fillStyle = `rgba(0, 150, 255, ${alpha * 0.3})`;
                    ctx.shadowColor = 'cyan';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(current.x, current.y, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cercle int√©rieur (c≈ìur brillant)
                    ctx.fillStyle = `rgba(100, 255, 255, ${alpha})`;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(current.x, current.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Point central ultra-brillant
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(current.x, current.y, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                
                // === PROJECTILE PURE √âNERGIE === (point focal de la tra√Æn√©e)
                ctx.save();
                
                // NOYAU CENTRAL ULTRA-BRILLANT
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Halo externe pulsant
                const pulseSize = 35 + Math.sin(this.timer * 0.01) * 10;
                ctx.shadowColor = 'rgba(0, 255, 255, 0.8)';
                ctx.shadowBlur = 50 * this.glowIntensity;
                ctx.fillStyle = `rgba(0, 150, 255, ${0.2 * this.glowIntensity})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Noyau principal
                ctx.shadowBlur = 30;
                ctx.fillStyle = `rgba(50, 255, 255, ${0.8 * this.glowIntensity})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // C≈ìur ultra-brillant
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 20;
                ctx.fillStyle = `rgba(255, 255, 255, ${this.glowIntensity})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Point central pur
                ctx.shadowBlur = 10;
                ctx.fillStyle = `rgba(255, 255, 255, 1.0)`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // üí• CLASSE PARTICLE STYLE TEKKEN - Impact bref et puissant
        class Particle {
            constructor(x, y, type = 'impact') {
                this.x = x;
                this.y = y;
                this.type = type;
                
                // Dur√©e de vie TR√àS courte pour style Tekken
                this.maxLife = 0.25; // 250ms max
                this.life = this.maxLife;
                
                // Vitesse et direction al√©atoire pour dispersion
                this.vx = (Math.random() - 0.5) * 150;
                this.vy = (Math.random() - 0.5) * 150;
                this.size = Math.random() * 4 + 2;
                
                // Couleur selon le type
                if (type === 'impact') {
                    this.color = `rgba(255, 255, 200, 1.0)`; // Blanc/dor√©
                } else if (type === 'special') {
                    this.color = `rgba(100, 200, 255, 1.0)`; // Bleu ninja
                }
                
                this.gravity = 300; // Chute rapide
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000;
                
                // Mouvement
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vy += this.gravity * dt;
                
                // Diminution de la vie (rapide !)
                this.life -= dt;
                
                return this.life > 0;
            }
            
            render(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Classe joueur avec sprites fixes
        class FixedPlayer {
            constructor(x, y, type, isPlayer1) {
                this.x = x;
                this.y = y;
                this.width = 80;
                this.height = 80;
                this.type = type;
                this.isPlayer1 = isPlayer1;
                this.health = 100;
                this.maxHealth = 100;
                this.facingLeft = false;
                
                this.animationState = 'idle';
                this.animationFrame = 1;
                this.animationTimer = 0;
                this.frameSpeed = 300;
                
                this.vx = 0;
                this.vy = 0;
                this.onGround = false;
                this.speed = 300;
                this.jumpPower = 500;
                this.gravity = 1500;
                
                this.isAttacking = false;
                this.attackTimer = 0;
                this.attackDuration = 1000;
                this.hasHit = false;
                
                // Syst√®me sp√©cial
                this.isChargingSpecial = false;
                this.specialPhase = 0;
                this.specialTimer = 0;
                this.specialPhaseDurations = [0, 300, 300, 300, 200, 250, 250];
                this.specialCooldown = 0;
                this.specialCooldownDuration = 3000;
                
                // Syst√®me de combos
                this.comboType = 'normal'; // 'normal', 'uppercut', 'low'
                this.lastAttackTime = 0;
                this.comboWindow = 600; // 600ms pour encha√Æner G+G (plus facile)
                this.isDoubleAttack = false;
                this.doubleAttackTimer = 0;
                
                // Debug visual
                this.debugText = "";
                this.debugTimer = 0;
                this.doubleAttackDuration = 600;
                
                // Syst√®me hurt am√©lior√©
                this.isHurt = false;
                this.hurtTimer = 0;
                
                // Syst√®me de chute au sol
                this.isDown = false;
                this.downTimer = 0;
                this.downDuration = 500; // 0.5 seconde au sol (encore r√©duit de moiti√©)
                
                // Syst√®me de r√©cup√©ration
                this.isGettingUp = false;
                this.getupTimer = 0;
                this.getupDuration = 900; // 0.9 secondes pour se relever (plus r√©aliste)
                
                // Syst√®me de dash
                this.isDashing = false;
                this.dashTimer = 0;
                this.dashDuration = 250; // 0.25 secondes de dash (plus court et pr√©cis) ‚ö°
                this.dashSpeed = 700; // Vitesse du dash ULTRA rapide ! üöÄ
                this.dashCooldown = 0;
                this.dashCooldownDuration = 1000; // 1 seconde entre chaque dash
                this.dashDirection = 0; // -1 gauche, 1 droite
                
                // Syst√®me de garde
                this.isBlocking = false;
                this.blockStun = 0;
                this.blockStunDuration = 300; // 0.3 secondes de stun apr√®s avoir bloqu√©
                this.blockDirection = 0; // Direction de la garde
                
                // NOUVEAUX SYST√àMES TACTIQUES DE LUMI√àRE
                this.lightDamageBonus = 0; // Bonus de d√©g√¢ts dans la lumi√®re
                this.lightSpeedBoost = 1.0; // Multiplicateur de vitesse
                this.lightVisionBonus = 1.0; // Am√©lioration de la port√©e d'attaque
                this.isStunned = false; // √âtat de paralysie
                this.stunTimer = 0; // Dur√©e de paralysie restante
                
                // üí™ SYST√àME D'ENDURANCE
                this.maxStamina = 100;
                this.stamina = 100;
                this.staminaRegenRate = 30; // Points par seconde
                this.staminaRegenDelay = 1000; // 1s avant r√©g√©n√©ration
                this.lastStaminaUse = 0;
                
                // Co√ªts en endurance
                this.dashStaminaCost = 25;
                this.gatlingStaminaCost = 5; // Par coup
                this.gatlingStaminaPerSecond = 20; // Par seconde maintenue
                
                // üî• NOUVEAU SYST√àME GATLING 9 FRAMES
                this.gatlingPhase = 0; // 0=inactif, 1=enclenchement(1-5), 2=attaque(6-9)
                this.gatlingFrameTimer = 0;
                this.gatlingEnclenchementSpeed = 200; // ms par frame d'enclenchement (DYNAMIQUE - 1 seconde totale)
                this.gatlingAttackSpeed = 80; // ms par frame d'attaque (ULTRA-RAPIDE mitraillette!)
                this.gatlingCurrentFrame = 1;
                
                // ‚öîÔ∏è SYST√àME WARRIOR COMBO 3-HIT
                this.isCombo = false; // √âtat de combo actif
                this.comboTimer = 0; // Timer simple comme attackTimer
                this.comboDuration = 0.4; // Dur√©e d'UN coup seulement
                this.comboWindow = 800; // Fen√™tre de 800ms pour encha√Æner
                this.lastComboTime = 0; // Temps du dernier coup
                this.currentHitDealt = false; // Si le coup actuel a √©t√© donn√©
                this.comboHitCount = 0; // Nombre de coups port√©s dans le combo
                this.comboDamage = 12; // D√©g√¢ts par coup du combo
                
                // ü¶ò SYST√àME DE DOUBLE SAUT
                this.canDoubleJump = false;
                this.hasDoubleJumped = false;
                this.doubleJumpPower = 400; // Un peu moins puissant que le saut normal (500)
                this.doubleJumpStaminaCost = 15;
                
                // Variables pour √©viter les sauts r√©p√©t√©s
                this.jumpKeyPressed = false;
                this.jumpKeyPressedP2 = false; // Variable s√©par√©e pour Player 2
                
                // üé≠ NOUVEAUX √âTATS POUR ANIMATIONS DE VICTOIRE/D√âFAITE
                this.isInVictoryPose = false;
                this.isInDefeatPose = false;
                this.victoryAnimationTimer = 0;
                this.defeatAnimationTimer = 0;
                this.victoryPoseSpeed = 200; // Vitesse d'animation de victoire (ms par frame) - plus lente pour 9 frames
                this.defeatPoseSpeed = 300;  // Vitesse d'animation de d√©faite (ms par frame) - plus lente pour bien voir
                
                // ‚öîÔ∏è SYST√àME DE CONTRES ET PARADES AVANC√âES
                this.perfectBlockWindow = 200; // 200ms pour parade parfaite
                this.perfectBlockTimer = 0;
                this.isPerfectBlocking = false;
                this.canCounter = false;
                this.counterWindow = 300; // 300ms pour contre-attaque apr√®s parade
                this.counterTimer = 0;
                this.guardBreakThreshold = 5; // 5 coups bloqu√©s = garde cass√©e
                this.currentBlockCount = 0;
                this.isGuardBroken = false;
                this.guardBreakDuration = 2000; // 2 secondes de vuln√©rabilit√©
                this.guardBreakTimer = 0;
                
                // ü¶Ö SYST√àME D'ATTAQUES A√âRIENNES
                this.canAirAttack = false;
                this.isAirAttacking = false;
                this.airAttackTimer = 0;
                this.airAttackDuration = 400;
                this.airComboCount = 0;
                this.maxAirCombo = 3;
                
                // üëª SYST√àME D'ESQUIVE PARFAITE (DASH INVINCIBILIT√â)
                this.perfectDodgeWindow = 100; // 100ms d'invincibilit√© au d√©but du dash
                this.isDodgeInvincible = false;
                this.dodgeInvincibilityTimer = 0;
                
                // üß± SYST√àME DE REBONDS SUR MURS
                this.canWallBounce = true;
                this.wallBounceForce = 300;
                this.isWallBouncing = false;
            }
            
            chargeSpecialAttack() {
                if (this.specialCooldown <= 0 && !this.isChargingSpecial) {
                    this.isChargingSpecial = true;
                    this.specialPhase = 1;
                    this.specialTimer = 0;
                    this.animationState = 'special';
                    this.updatePhaseDisplay();
                    
                    // üé¨ D√âCLENCHEMENT DE LA CAM√âRA DYNAMIQUE !
                    startSpecialCamera(this);
                    
                    // üéµ SON DE CHARGE SP√âCIALE !
                    playChargeSound();
                    
                    console.log(`${this.type} : D√©but technique sp√©ciale !`);
                }
            }
            
            updatePhaseDisplay() {
                const phaseNames = ['Normal', 'Concentration', 'Accumulation', 'Charge Max', 'LANCEMENT!', 'R√©cup√©ration', 'Fin'];
                document.getElementById('specialPhase').textContent = `${this.type} - ${phaseNames[this.specialPhase]}`;
            }
            
            executeSpecialAttack() {
                // üé¨ TERMINER L'EFFET DE CAM√âRA SP√âCIALE AVANT LE TIR !
                endSpecialCamera();
                
                const projectileX = this.facingLeft ? this.x - 40 : this.x + this.width;
                const projectileY = this.y;
                const direction = this.facingLeft ? -1 : 1;
                
                const projectile = new FixedProjectile(projectileX, projectileY, direction, this);
                projectiles.push(projectile);
                
                timeScale = 0.3;
                console.log(`${this.type} : HADOKEN lanc√© !`);
                
                setTimeout(() => { timeScale = 1.0; }, 1000);
            }
            
            // Syst√®me de dash avec endurance
            startDash(direction) {
                if (this.dashCooldown <= 0 && !this.isDashing && !this.isAttacking && !this.isHurt && !this.isDown && this.stamina >= this.dashStaminaCost) {
                    // Consommer l'endurance
                    this.stamina -= this.dashStaminaCost;
                    this.lastStaminaUse = Date.now();
                    
                    this.isDashing = true;
                    this.dashTimer = 0;
                    this.dashDirection = direction;
                    this.dashCooldown = this.dashCooldownDuration;
                    this.facingLeft = direction < 0; // Mettre √† jour l'orientation !
                    this.animationState = 'dash'; // Utilise l'animation de dash sp√©cifique
                    this.animationFrame = 1; // Commencer √† la frame 1
                    
                    console.log(`${this.type} : Dash ${direction > 0 ? 'droite' : 'gauche'} ! Stamina: ${this.stamina}`);
                } else if (this.stamina < this.dashStaminaCost) {
                    console.log(`${this.type} : Pas assez d'endurance pour dash ! (${this.stamina}/${this.dashStaminaCost})`);
                }
            }
            
            // Syst√®me de garde am√©lior√©
            startBlocking(direction) {
                if (!this.isAttacking && !this.isHurt && !this.isDown && !this.isDashing && this.blockStun <= 0 && !this.isGuardBroken) {
                    this.isBlocking = true;
                    this.blockDirection = direction;
                    this.animationState = 'shield'; // Utilise l'animation de shield sp√©cifique
                    this.animationFrame = 1; // Commencer √† la frame 1
                    
                    // üõ°Ô∏è Possibilit√© de parade parfaite si timing correct
                    this.startPerfectBlock();
                }
            }
            
            stopBlocking() {
                this.isBlocking = false;
            }
            
            // Obtenir la vitesse d'animation selon l'√©tat actuel
            getCurrentFrameSpeed() {
                switch (this.animationState) {
                    case 'gatling':
                        // SYST√àME GATLING: vitesses diff√©rentes selon la phase
                        if (this.gatlingPhase === 1) {
                            return this.gatlingEnclenchementSpeed; // 600ms pour pr√©paration
                        } else if (this.gatlingPhase === 2) {
                            return this.gatlingAttackSpeed; // 120ms pour attaque
                        }
                        return 600; // Fallback
                    case 'dash':
                        return 200; // Animation normale pour le dash
                    case 'shield':
                        return 500; // Animation plus lente en garde
                    case 'attack':
                    case 'uppercut':
                    case 'low':
                    case 'double':
                        return 300; // Vitesse normale pour les attaques
                    case 'idle':
                        return 300; // Vitesse normale pour idle
                    case 'walk':
                        // üö∂‚Äç‚ôÇÔ∏è SYST√àME PARFAIT: Synchronisation math√©matique absolue
                        const moveSpeed = Math.abs(this.vx);
                        if (moveSpeed === 0) return 400; // Animation lente √† l'arr√™t
                        
                        // üßÆ FORMULE MAGIQUE: Chaque frame = distance pr√©cise parcourue
                        // Objectif: 1 cycle complet d'animation (4 frames) = 80 pixels
                        const pixelsPerCycle = 80;
                        const framesPerCycle = 4;
                        const pixelsPerFrame = pixelsPerCycle / framesPerCycle; // 20 pixels par frame
                        
                        // Calcul du temps n√©cessaire pour parcourir 20 pixels √† la vitesse actuelle
                        const timePerFrame = (pixelsPerFrame / moveSpeed) * 1000; // En millisecondes
                        
                        // Contraintes min/max pour √©viter les extr√™mes
                        const perfectSpeed = Math.max(100, Math.min(500, timePerFrame));
                        
                        // Lissage ultra-pr√©cis avec momentum
                        if (!this.walkSpeedHistory) this.walkSpeedHistory = [];
                        this.walkSpeedHistory.push(perfectSpeed);
                        if (this.walkSpeedHistory.length > 5) this.walkSpeedHistory.shift();
                        
                        // Moyenne mobile pour ultra-fluidit√©
                        const smoothSpeed = this.walkSpeedHistory.reduce((a, b) => a + b, 0) / this.walkSpeedHistory.length;
                        
                        return Math.round(smoothSpeed);
                    case 'hurt':
                        return 400; // Plus lent pour hurt
                    default:
                        return 300; // Vitesse par d√©faut
                }
            }

            update(deltaTime) {
                const dt = deltaTime / 1000;
                const scaledDeltaTime = deltaTime * timeScale;
                const scaledDt = dt * timeScale;
                
                // üí™ GESTION DE L'ENDURANCE
                const currentTime = Date.now();
                
                // R√©g√©n√©ration d'endurance apr√®s d√©lai
                if (currentTime - this.lastStaminaUse > this.staminaRegenDelay && this.stamina < this.maxStamina) {
                    this.stamina += this.staminaRegenRate * dt;
                    this.stamina = Math.min(this.stamina, this.maxStamina);
                }
                
                // üé≠ GESTION DES ANIMATIONS DE VICTOIRE/D√âFAITE
                if (this.isInVictoryPose) {
                    this.victoryAnimationTimer += deltaTime;
                    
                    // Animation de victoire avec 9 frames (pose compl√®te)
                    if (this.victoryAnimationTimer >= this.victoryPoseSpeed) {
                        if (this.animationFrame < 9) {
                            this.animationFrame++;
                            this.victoryAnimationTimer = 0;
                        } else {
                            // Pause √† la fin de l'animation, puis recommencer
                            if (this.victoryAnimationTimer >= this.victoryPoseSpeed * 3) {
                                this.animationFrame = 1; // Recommencer l'animation
                                this.victoryAnimationTimer = 0;
                            }
                        }
                    }
                    
                    // Bloquer tous les autres mouvements pendant la victoire
                    this.vx = 0;
                    this.vy = 0;
                    return; // Ne pas traiter d'autres logiques de mouvement
                }
                
                if (this.isInDefeatPose) {
                    this.defeatAnimationTimer += deltaTime;
                    
                    // Animation de d√©faite avec 4 frames seulement
                    if (this.defeatAnimationTimer >= this.defeatPoseSpeed) {
                        this.animationFrame++;
                        if (this.animationFrame > 4) {
                            this.animationFrame = 4; // Rester sur la derni√®re frame de d√©faite
                        }
                        this.defeatAnimationTimer = 0;
                    }
                    
                    // Bloquer tous les autres mouvements pendant la d√©faite
                    this.vx = 0;
                    this.vy = 0;
                    return; // Ne pas traiter d'autres logiques de mouvement
                }
                
                // ‚öîÔ∏è GESTION DES NOUVEAUX SYST√àMES DE COMBAT AVANC√â
                
                // Timer de parade parfaite
                if (this.isPerfectBlocking) {
                    this.perfectBlockTimer -= deltaTime;
                    if (this.perfectBlockTimer <= 0) {
                        this.isPerfectBlocking = false;
                    }
                }
                
                // Timer de contre-attaque
                if (this.canCounter) {
                    this.counterTimer -= deltaTime;
                    if (this.counterTimer <= 0) {
                        this.canCounter = false;
                    }
                }
                
                // Timer de garde cass√©e
                if (this.isGuardBroken) {
                    this.guardBreakTimer -= deltaTime;
                    if (this.guardBreakTimer <= 0) {
                        this.isGuardBroken = false;
                        console.log(`üõ°Ô∏è ${this.type}: Guard recovered!`);
                    }
                }
                
                // Timer d'attaque a√©rienne
                if (this.isAirAttacking) {
                    this.airAttackTimer -= deltaTime;
                    if (this.airAttackTimer <= 0) {
                        this.isAirAttacking = false;
                    }
                }
                
                // Timer d'invincibilit√© d'esquive
                if (this.isDodgeInvincible) {
                    this.dodgeInvincibilityTimer -= deltaTime;
                    if (this.dodgeInvincibilityTimer <= 0) {
                        this.isDodgeInvincible = false;
                    }
                }
                
                // Reset combo a√©rien au sol
                if (this.onGround) {
                    this.airComboCount = 0;
                    this.canAirAttack = false;
                } else {
                    this.canAirAttack = true;
                }
                
                // V√©rification rebond sur murs
                checkWallBounce(this);
                
                // ÔøΩ Mise √† jour des particules
                if (this.particles && this.particles.length > 0) {
                    this.particles = this.particles.filter(particle => {
                        particle.update(dt);
                        return particle.life > 0;
                    });
                }
                
                // ÔøΩüî• SYST√àME GATLING IND√âPENDANT - bas√© sur temps r√©el
                if (this.isGatling && this.gatlingPhase > 0) {
                    const currentTime = Date.now();
                    
                    // Utiliser le temps r√©el au lieu des deltas pour √©viter les accumulations
                    if (!this.gatlingLastFrameTime) {
                        this.gatlingLastFrameTime = currentTime;
                    }
                    
                    const timeSinceLastFrame = currentTime - this.gatlingLastFrameTime;
                    const currentSpeed = this.gatlingPhase === 1 ? this.gatlingEnclenchementSpeed : this.gatlingAttackSpeed;
                    const elapsedTime = currentTime - this.gatlingStartTime;
                    
                    console.log(`‚è±Ô∏è GATLING REAL TIME: Frame=${this.gatlingCurrentFrame}, TimeSinceFrame=${timeSinceLastFrame}ms, Speed=${currentSpeed}ms, Elapsed=${elapsedTime}ms`);
                    
                    if (timeSinceLastFrame >= currentSpeed) {
                        this.gatlingLastFrameTime = currentTime; // Reset du temps de frame
                        this.gatlingCurrentFrame++;
                        this.animationFrame = this.gatlingCurrentFrame;
                        // PHASE 1 : Enclenchement (frames 1-5) - PR√âPARATION DRAMATIQUE
                        if (this.gatlingPhase === 1) {
                            console.log(`üé≠ PR√âPARATION GATLING Frame: ${this.gatlingCurrentFrame}/5 - Vitesse: ${currentSpeed}ms (${currentSpeed/1000}s)`);
                            
                            if (this.gatlingCurrentFrame > 5) {
                                // Transition vers phase d'attaque
                                this.gatlingPhase = 2;
                                this.gatlingCurrentFrame = 6;
                                this.animationFrame = 6;
                                this.isAttacking = true; // ‚úÖ Activer isAttacking seulement en phase d'attaque!
                                const preparationDuration = Date.now() - this.gatlingStartTime;
                                console.log(`‚ö°üí• PHASE ATTAQUE D√âCLENCH√âE! Pr√©paration dur√©e: ${preparationDuration}ms (attendue: 3000ms)`);
                            }
                        }
                        
                        // PHASE 2 : Attaque continue (frames 6-9)
                        else if (this.gatlingPhase === 2) {
                            // V√©rifier l'endurance AVANT de continuer
                            const staminaCost = 8;
                            if (this.stamina < staminaCost) {
                                console.log(`‚ùå Endurance √©puis√©e (${this.stamina.toFixed(1)}/${staminaCost}) - Arr√™t Gatling!`);
                                this.stopGatlingAttack();
                                return;
                            }
                            
                            // Boucle sur les frames 6-9
                            if (this.gatlingCurrentFrame > 9) {
                                this.gatlingCurrentFrame = 6; // Retour √† la frame 6
                                this.animationFrame = 6;
                                
                                // Consommer endurance seulement √† chaque cycle complet (retour frame 6)
                                this.stamina -= staminaCost;
                                this.lastStaminaUse = currentTime;
                                console.log(`‚ö° Cycle Gatling - Endurance: ${this.stamina.toFixed(1)}/${this.maxStamina}`);
                                
                                // Infliger des d√©g√¢ts √† chaque cycle
                                this.performGatlingHit();
                            }
                        }
                    }
                    
                    // Arr√™ter si touche Gatling rel√¢ch√©e (seulement apr√®s la phase d'enclenchement)
                    const gatlingKey = this.isPlayer1 ? 'KeyO' : 'Numpad3';
                    if (!keys[gatlingKey] && this.gatlingPhase === 2) {
                        console.log(`üî¥ Gatling arr√™t√©: touche ${gatlingKey} rel√¢ch√©e`);
                        this.stopGatlingAttack();
                    }
                }
                
                // ‚öîÔ∏è SYST√àME WARRIOR COMBO - UN COUP √Ä LA FOIS, il faut encha√Æner!
                if (this.isCombo) {
                    this.comboTimer += scaledDt;
                    
                    // Calculer quelle frame afficher pour CE coup seulement
                    const progress = this.comboTimer / this.comboDuration; // 0 √† 1
                    const currentFrame = Math.min(Math.floor(progress * 3) + 1 + (this.comboHitCount * 3), 9); // Frames 1-3, 4-6, ou 7-9
                    this.animationFrame = currentFrame;
                    
                    // D√©clencher le coup au milieu de l'animation
                    if (this.comboTimer >= this.comboDuration * 0.5 && !this.currentHitDealt) {
                        this.performComboHit(this.comboHitCount + 1);
                        this.currentHitDealt = true; // Marquer ce coup comme donn√©
                    }
                    
                    // Terminer ce coup et attendre le prochain input
                    if (this.comboTimer >= this.comboDuration) {
                        this.finishCurrentComboHit();
                    }
                }
                
                if (this.specialCooldown > 0) {
                    this.specialCooldown -= deltaTime;
                }
                
                // Gestion des cooldowns
                if (this.dashCooldown > 0) {
                    this.dashCooldown -= deltaTime;
                }
                
                if (this.blockStun > 0) {
                    this.blockStun -= deltaTime;
                }
                
                // Gestion du dash
                if (this.isDashing) {
                    this.dashTimer += deltaTime;
                    this.vx = this.dashDirection * this.dashSpeed;
                    
                    // Effets de particules supprim√©s
                    
                    if (this.dashTimer >= this.dashDuration) {
                        this.isDashing = false;
                        this.dashTimer = 0;
                        if (!this.isCombo) { // Ne pas interf√©rer avec le combo warrior
                            this.animationState = 'idle'; // Retour √† l'√©tat idle
                            this.animationFrame = 1;
                        }
                        
                        // Nettoyage des particules supprim√©
                    }
                }
                
                // Mise √† jour des particules supprim√©e
                
                if (this.isChargingSpecial) {
                    this.specialTimer += deltaTime;
                    
                    const currentPhaseDuration = this.specialPhaseDurations[this.specialPhase];
                    
                    if (this.specialTimer >= currentPhaseDuration) {
                        this.specialTimer = 0;
                        this.specialPhase++;
                        
                        if (this.specialPhase === 5) {
                            this.executeSpecialAttack();
                        } else if (this.specialPhase > 6) { // CORRIG√â : 6 au lieu de 10 car vous avez 6 sprites
                            this.isChargingSpecial = false;
                            this.specialPhase = 0;
                            this.specialCooldown = this.specialCooldownDuration;
                            if (!this.isCombo) { // Ne pas interf√©rer avec le combo warrior
                                this.animationState = 'idle';
                                this.animationFrame = 1; // CORRECTION: Commencer √† 1, pas 0
                            }
                            
                            // La cam√©ra est d√©j√† termin√©e avant le tir, plus besoin ici
                        }
                        
                        this.updatePhaseDisplay();
                        if (this.isChargingSpecial) {
                            this.animationFrame = this.specialPhase;
                        }
                    }
                    
                    return;
                }
                
                // ü•ä Gestion du Gatling Attack
                if (this.isGatling) {
                    this.gatlingTimer += deltaTime * 1000; // Convert to ms
                    
                    if (this.gatlingTimer >= this.gatlingInterval) {
                        this.gatlingTimer = 0;
                        this.gatlingCount++;
                        
                        // Cr√©er un coup de gatling
                        this.performGatlingHit();
                        
                        if (this.gatlingCount >= this.gatlingMaxHits) {
                            // Fin du gatling
                            this.isGatling = false;
                            this.isAttacking = false;
                            this.animationState = 'idle';
                            this.animationFrame = 1;
                            console.log(`üî• ${this.type}: Gatling termin√©! ${this.gatlingCount} coups!`);
                        }
                    }
                }
                
                let isMoving = false;
                
                // Emp√™cher toute action si le joueur est au sol ou se rel√®ve
                if (!this.isDown && !this.isGettingUp) {
                    if (this.isPlayer1) {
                        // Syst√®me de garde et perfect parry (S pour bloquer)
                        if (keys['KeyS'] && !this.isDashing) {
                            const guardDirection = this.facingLeft ? -1 : 1;
                            if (!this.isBlocking) {
                                this.startBlocking(guardDirection);
                                // D√©marrer perfect parry si d√©but de garde
                                this.startPerfectBlock();
                                console.log("üõ°Ô∏è JOUEUR 1 - PERFECT PARRY WINDOW!");
                            }
                        } else if (!keys['KeyS']) {
                            this.stopBlocking();
                        }
                        
                        // Syst√®me de dash et perfect dodge (double tap ou Q/E)
                        if (keys['KeyQ'] && !this.isBlocking) {
                            // V√©rifier perfect dodge timing
                            const opponent = this.isPlayer1 ? players[1] : players[0];
                            if (opponent && opponent.isAttacking && Math.abs(opponent.x - this.x) < 80) {
                                this.startPerfectDodge(-1); // Perfect dodge gauche
                                console.log("üí® JOUEUR 1 - PERFECT DODGE GAUCHE!");
                            } else {
                                this.startDash(-1); // Dash gauche normal
                            }
                        } else if (keys['KeyE'] && !this.isBlocking) {
                            // V√©rifier perfect dodge timing
                            const opponent = this.isPlayer1 ? players[1] : players[0];
                            if (opponent && opponent.isAttacking && Math.abs(opponent.x - this.x) < 80) {
                                this.startPerfectDodge(1); // Perfect dodge droite
                                console.log("üí® JOUEUR 1 - PERFECT DODGE DROITE!");
                            } else {
                                this.startDash(1); // Dash droite normal
                            }
                        }
                        
                        // Mouvements normaux (d√©sactiv√©s pendant dash et garde)
                        if (!this.isDashing && !this.isBlocking) {
                            if (keys['KeyA']) {
                                this.vx = -this.speed;
                                this.facingLeft = true;
                                isMoving = true;
                            } else if (keys['KeyD']) {
                                this.vx = this.speed;
                                this.facingLeft = false;
                                isMoving = true;
                            } else {
                                this.vx = 0;
                            }
                        }
                        
                        // Gestion du saut avec d√©tection de pression de touche
                        if (keys['Comma'] && !this.isBlocking) {
                            if (!this.jumpKeyPressed) { // Seulement si la touche vient d'√™tre press√©e
                                if (this.onGround) {
                                    // Saut normal
                                    this.vy = -this.jumpPower;
                                    this.onGround = false;
                                    this.canDoubleJump = true;
                                    this.hasDoubleJumped = false;
                                } else if (this.canDoubleJump && !this.hasDoubleJumped && this.stamina >= this.doubleJumpStaminaCost) {
                                    // Double saut
                                    this.vy = -this.doubleJumpPower;
                                    this.hasDoubleJumped = true;
                                    this.canDoubleJump = false;
                                    this.stamina -= this.doubleJumpStaminaCost;
                                }
                                this.jumpKeyPressed = true;
                            }
                        } else {
                            this.jumpKeyPressed = false; // R√©initialiser quand la touche est rel√¢ch√©e
                        }
                        
                        // Attaques a√©riennes (disponibles seulement en l'air)
                        if (!this.onGround && this.canAirAttack) {
                            if (keys['KeyI'] && !this.isAirAttacking) {
                                this.startAirAttack();
                                console.log("‚úàÔ∏è JOUEUR 1 - AIR ATTACK I!");
                            } else if (keys['KeyJ'] && !this.isAirAttacking) {
                                this.startAirAttack();
                                console.log("‚úàÔ∏è JOUEUR 1 - AIR ATTACK J!");
                            } else if (keys['KeyK'] && !this.isAirAttacking) {
                                this.startAirAttack();
                                console.log("‚úàÔ∏è JOUEUR 1 - AIR ATTACK K!");
                            } else if (keys['KeyZ'] && !this.isAirAttacking) {
                                this.startAirAttack();
                                console.log("‚úàÔ∏è JOUEUR 1 - AIR ATTACK Z!");
                            }
                        }
                        
                        // Touches d'attaque et combos (bloqu√©es pendant garde)
                        if (keys['KeyI'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                        if (keys['KeyJ'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                        if (keys['KeyK'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            console.log("üî• JOUEUR 1 - TOUCHE K PRESS√âE!");
                            this.handleComboAttack();
                        }
                        if (keys['KeyZ'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            console.log("üí• JOUEUR 1 - TOUCHE Z PRESS√âE!");
                            this.handleComboAttack();
                        }
                        if (keys['KeyO'] && !this.isGatling && !this.isHurt && !this.isBlocking) {
                            console.log("ü•ä JOUEUR 1 - GATLING ATTACK O!");
                            this.startGatlingAttack();
                        }
                    } else {
                        // Syst√®me de garde et perfect parry (ArrowDown pour bloquer)
                        if (keys['ArrowDown'] && !this.isDashing) {
                            const guardDirection = this.facingLeft ? -1 : 1;
                            if (!this.isBlocking) {
                                console.log("üõ°Ô∏è GARDE ACTIV√âE!");
                                this.startBlocking(guardDirection);
                                // D√©marrer perfect parry si d√©but de garde
                                this.startPerfectBlock();
                                console.log("üõ°Ô∏è JOUEUR 2 - PERFECT PARRY WINDOW!");
                            }
                        } else if (!keys['ArrowDown']) {
                            this.stopBlocking();
                        }
                        
                        // Syst√®me de dash et perfect dodge (Digit0 et Enter)
                        if (keys['Digit0'] && !this.isBlocking) {
                            // V√©rifier perfect dodge timing
                            const opponent = this.isPlayer1 ? players[1] : players[0];
                            if (opponent && opponent.isAttacking && Math.abs(opponent.x - this.x) < 80) {
                                this.startPerfectDodge(-1); // Perfect dodge gauche
                                console.log("üí® JOUEUR 2 - PERFECT DODGE GAUCHE!");
                            } else {
                                console.log("üí® DASH GAUCHE!");
                                this.startDash(-1); // Dash gauche normal
                            }
                        } else if (keys['Enter'] && !this.isBlocking) {
                            // V√©rifier perfect dodge timing
                            const opponent = this.isPlayer1 ? players[1] : players[0];
                            if (opponent && opponent.isAttacking && Math.abs(opponent.x - this.x) < 80) {
                                this.startPerfectDodge(1); // Perfect dodge droite
                                console.log("üí® JOUEUR 2 - PERFECT DODGE DROITE!");
                            } else {
                                console.log("üí® DASH DROITE!");
                                this.startDash(1); // Dash droite normal
                            }
                        }
                        
                        // Mouvements normaux (d√©sactiv√©s pendant dash et garde)
                        if (!this.isDashing && !this.isBlocking) {
                            if (keys['ArrowLeft']) {
                                this.vx = -this.speed;
                                this.facingLeft = true;
                                isMoving = true;
                            } else if (keys['ArrowRight']) {
                                this.vx = this.speed;
                                this.facingLeft = false;
                                isMoving = true;
                            } else {
                                this.vx = 0;
                            }
                        }
                        
                        // Gestion du saut pour Player 2 avec d√©tection de pression de touche
                        if (keys['ArrowUp'] && !this.isBlocking) {
                            if (!this.jumpKeyPressedP2) { // Seulement si la touche vient d'√™tre press√©e
                                if (this.onGround) {
                                    // Saut normal
                                    this.vy = -this.jumpPower;
                                    this.onGround = false;
                                    this.canDoubleJump = true;
                                    this.hasDoubleJumped = false;
                                } else if (this.canDoubleJump && !this.hasDoubleJumped && this.stamina >= this.doubleJumpStaminaCost) {
                                    // Double saut
                                    this.vy = -this.doubleJumpPower;
                                    this.hasDoubleJumped = true;
                                    this.canDoubleJump = false;
                                    this.stamina -= this.doubleJumpStaminaCost;
                                }
                                this.jumpKeyPressedP2 = true;
                            }
                        } else {
                            this.jumpKeyPressedP2 = false; // R√©initialiser quand la touche est rel√¢ch√©e
                        }
                        
                        // Attaques a√©riennes pour Player 2 (disponibles seulement en l'air)
                        if (!this.onGround && this.canAirAttack) {
                            if (keys['KeyL'] && !this.isAirAttacking) {
                                this.startAirAttack();
                                console.log("‚úàÔ∏è JOUEUR 2 - AIR ATTACK L!");
                            } else if (keys['Numpad1'] && !this.isAirAttacking) {
                                this.startAirAttack();
                                console.log("‚úàÔ∏è JOUEUR 2 - AIR ATTACK 1!");
                            } else if (keys['Numpad2'] && !this.isAirAttacking) {
                                this.startAirAttack();
                                console.log("‚úàÔ∏è JOUEUR 2 - AIR ATTACK 2!");
                            }
                        }
                        
                        // Touches d'attaque et combos (bloqu√©es pendant garde)
                        if (keys['KeyL'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                        if (keys['Numpad1'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                        if (keys['Numpad2'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                        if (keys['Numpad3'] && !this.isGatling && !this.isHurt && !this.isBlocking) {
                            this.startGatlingAttack();
                        }
                        
                        // ü§ñ IA SIMPLE POUR LE JOUEUR 2 (pour tester les contre-attaques)
                        if (aiEnabled && !this.isPlayer1) {
                            this.simpleAI(deltaTime);
                        }
                    }
                }
                
                this.vy += this.gravity * scaledDt;
                
                // Appliquer la friction horizontale (surtout au sol)
                if (this.onGround) {
                    const friction = this.isDown ? 0.85 : 0.92; // Plus de friction quand knockdown
                    this.vx *= friction;
                    
                    // Arr√™ter compl√®tement si la vitesse devient tr√®s faible
                    if (Math.abs(this.vx) < 5) {
                        this.vx = 0;
                    }
                }
                
                this.x += this.vx * scaledDt;
                this.y += this.vy * scaledDt;
                
                // Collision avec le sol principal
                if (this.y >= 620) {
                    this.y = 620;
                    this.vy = 0;
                    this.onGround = true;
                    // R√©initialiser les variables du double saut quand on touche le sol
                    this.canDoubleJump = false;
                    this.hasDoubleJumped = false;
                }
                
                // Syst√®me de collision avec les plateformes accessibles
                const platforms = [
                    {x: 280, y: 600, width: 220, height: 20}, // Plateforme gauche
                    {x: 680, y: 480, width: 220, height: 20}, // Plateforme droite  
                    {x: 480, y: 380, width: 220, height: 20}  // Plateforme centrale
                ];
                
                // V√©rifier les collisions avec chaque plateforme
                for (const platform of platforms) {
                    // V√©rifier si le joueur entre en collision avec cette plateforme
                    if (this.x + this.width > platform.x && 
                        this.x < platform.x + platform.width && 
                        this.y + this.height > platform.y && 
                        this.y < platform.y + platform.height) {
                        
                        // Collision par le dessus (atterrissage)
                        if (this.vy > 0 && this.y < platform.y) {
                            this.y = platform.y - this.height;
                            this.vy = 0;
                            this.onGround = true;
                            // R√©initialiser les variables du double saut
                            this.canDoubleJump = false;
                            this.hasDoubleJumped = false;
                        }
                        // Collision par le dessous (plafond)
                        else if (this.vy < 0 && this.y > platform.y) {
                            this.y = platform.y + platform.height;
                            this.vy = 0;
                        }
                        // Collisions lat√©rales
                        else if (this.vx > 0 && this.x < platform.x) {
                            this.x = platform.x - this.width;
                            this.vx = 0;
                        }
                        else if (this.vx < 0 && this.x > platform.x + platform.width) {
                            this.x = platform.x + platform.width;
                            this.vx = 0;
                        }
                    }
                }
                
                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                
                this.updateAnimation(scaledDeltaTime, isMoving);
                
                // Gestion du timer de double attaque
                if (this.isDoubleAttack) {
                    this.doubleAttackTimer += scaledDeltaTime;
                    if (this.doubleAttackTimer >= this.doubleAttackDuration) {
                        this.isDoubleAttack = false;
                        this.doubleAttackTimer = 0;
                    }
                }
                
                if (this.isAttacking) {
                    this.attackTimer += scaledDeltaTime;
                    if (this.attackTimer >= this.attackDuration) {
                        this.isAttacking = false;
                        this.attackTimer = 0;
                        this.hasHit = false;
                        this.comboType = 'normal'; // Reset combo type
                    }
                }
            }
            
            updateAnimation(deltaTime, isMoving) {
                // Gestion des timers
                if (this.hurtTimer > 0) {
                    this.hurtTimer -= deltaTime;
                    if (this.hurtTimer <= 0) {
                        this.isHurt = false;
                    }
                }
                
                let newState;
                
                // Debug pour voir l'√©tat actuel
                if (this.isDown) {
                    console.log(`üîç ${this.type}: isDown=${this.isDown}, downTimer=${this.downTimer}`);
                }
                
                // G√©rer les √©tats dans le bon ordre
                if (this.isDown && this.downTimer > 0) {
                    // D√©cr√©menter le timer pendant qu'on est au sol (deltaTime est d√©j√† en millisecondes)
                    this.downTimer -= deltaTime;
                    newState = 'down'; // √âtat au sol
                    console.log(`DEBUG: ${this.type} is DOWN - Timer: ${this.downTimer.toFixed(0)}`);
                    
                    if (this.downTimer <= 0) {
                        // Passer √† la phase de r√©cup√©ration
                        this.isDown = false;
                        this.isGettingUp = true;
                        this.getupTimer = this.getupDuration;
                        console.log(`${this.type}: D√©but de la r√©cup√©ration`);
                    }
                } else if (this.isGettingUp && this.getupTimer > 0) {
                    // D√©cr√©menter le timer pendant qu'on se rel√®ve (deltaTime est d√©j√† en millisecondes)
                    this.getupTimer -= deltaTime;
                    newState = 'getup'; // √âtat de r√©cup√©ration
                    console.log(`DEBUG: ${this.type} is GETTING UP - Timer: ${this.getupTimer.toFixed(0)}`);
                    
                    if (this.getupTimer <= 0) {
                        this.isGettingUp = false;
                        console.log(`${this.type}: R√©cup√©ration termin√©e`);
                    }
                } else if (this.isHurt) {
                    newState = 'hurt'; // √âtat bless√©
                } else if (this.isCombo) {
                    newState = 'combo'; // ‚öîÔ∏è PRIORIT√â ABSOLUE pour combo warrior
                } else if (this.isGatling && this.gatlingPhase > 0) {
                    newState = 'gatling'; // PRIORIT√â ABSOLUE pour Gatling avant TOUT
                } else if (this.isChargingSpecial) {
                    newState = 'special';
                } else if (this.isAttacking) {
                    // Utiliser l'√©tat d'animation d√©fini par le combo au lieu de forcer 'attack'
                    newState = this.animationState; // Garder l'√©tat actuel (uppercut, low, double, attack)
                } else if (this.isDashing) {
                    newState = 'dash';
                } else if (this.isBlocking) {
                    newState = 'shield';
                } else if (!this.onGround) {
                    newState = 'jump';
                } else if (isMoving) {
                    newState = 'walk';
                } else {
                    newState = 'idle';
                }
                
                if (newState !== this.animationState) {
                    this.animationState = newState;
                    // üî• NE PAS r√©initialiser animationFrame si on passe en mode Gatling
                    if (!(newState === 'gatling' && this.isGatling && this.gatlingPhase > 0)) {
                        this.animationFrame = 1;
                        this.animationTimer = 0;
                    }
                    console.log(`üé¨ √âtat chang√© vers: ${newState}, Gatling: ${this.isGatling}, Phase: ${this.gatlingPhase}`);
                }
                
                // üî• S√âPARATION COMPL√àTE: syst√®me Gatling VS syst√®me normal
                if (this.isGatling && this.gatlingPhase > 0) {
                    // ‚ö° MODE GATLING: ne toucher √† RIEN du syst√®me normal
                    console.log(`üîí Mode Gatling actif - syst√®me normal BLOQU√â`);
                } else {
                    // üé¨ MODE NORMAL: animation normale seulement si pas en Gatling
                    this.animationTimer += deltaTime;
                    
                    // Obtenir la vitesse d'animation selon l'√©tat actuel
                    const currentFrameSpeed = this.getCurrentFrameSpeed();
                    
                    if (this.animationTimer >= currentFrameSpeed) {
                        this.animationTimer = 0;
                        
                        if (!this.isChargingSpecial) {
                            this.animationFrame++;
                            
                            const maxFrames = {
                                'idle': 3, 'walk': 8, 'jump': 5, 'attack': 3, 'hurt': 2, 'special': 6,
                                'uppercut': 3, 'low': 3, 'double': 3, 'down': 3, 'getup': 4,
                                'dash': 3, 'shield': 3
                            };
                            
                            const maxFrame = maxFrames[this.animationState] || 1;
                            
                            // Debug maxFrame
                            if (this.animationState === 'walk' || this.animationState === 'jump') {
                                console.log(`üîß ${this.animationState}: maxFrame=${maxFrame}, currentFrame=${this.animationFrame}`);
                            }
                            
                            if (this.animationFrame > maxFrame) {
                                this.animationFrame = 1;
                            }
                        }
                    }
                }
            }
            
            handleComboAttack() {
                const currentTime = Date.now();
                const timeSinceLastAttack = currentTime - this.lastAttackTime;
                
                // Initialiser le compteur de combo G si n√©cessaire
                if (!this.comboGCounter) this.comboGCounter = 0;
                if (!this.lastComboGTime) this.lastComboGTime = 0;
                
                // D√©tection des combos selon les touches press√©es
                if (keys['KeyJ']) {
                    // Uppercut (J)
                    this.comboType = 'uppercut';
                    this.comboGCounter = 0; // Reset combo G
                    this.attack();
                    console.log(`${this.type}: UPPERCUT!`);
                } else if (keys['KeyK']) {
                    // Attaque basse (K)
                    this.comboType = 'low';
                    this.comboGCounter = 0; // Reset combo G
                    this.attack();
                    console.log(`üî• ${this.type}: ATTAQUE BASSE - LOW ATTACK!`);
                } else if (keys['KeyZ']) {
                    // Attaque sp√©ciale Z
                    this.comboType = 'special';
                    this.comboGCounter = 0; // Reset combo G
                    this.attack();
                    console.log(`üí• ${this.type}: ATTAQUE SP√âCIALE Z!`);
                } else if (keys['KeyO']) {
                    // GATLING ATTACK maintenu avec O!
                    if (!this.isGatling && this.stamina >= this.gatlingStaminaCost) {
                        this.startGatlingAttack();
                        console.log(`ü•ä ${this.type}: GATLING ATTACK ACTIV√â!`);
                    }
                    return;
                } else if (keys['KeyI']) {
                    // ü•∑‚öîÔ∏è ATTAQUE DIFF√âRENTE SELON LE PERSONNAGE
                    if (this.type.toLowerCase().includes('warrior')) {
                        // WARRIOR = COMBO √Ä ENCHA√éNER (il faut appuyer plusieurs fois)
                        const currentTime = Date.now();
                        const timeSinceLastCombo = currentTime - (this.lastComboTime || 0);
                        
                        if (!this.isCombo && !this.isAttacking) {
                            // Premier coup OU nouveau combo dans la fen√™tre
                            if (this.comboHitCount === 0 || timeSinceLastCombo <= this.comboWindow) {
                                console.log(`üîç Encha√Ænement ${this.comboHitCount + 1}/3 - Timing: ${timeSinceLastCombo}ms`);
                                this.startWarriorCombo();
                            } else {
                                // Trop tard, recommencer √† z√©ro
                                console.log(`‚è∞ Fen√™tre expir√©e (${timeSinceLastCombo}ms > ${this.comboWindow}ms) - Reset`);
                                this.resetCombo();
                                this.startWarriorCombo();
                            }
                        }
                    } else {
                        // NINJA = Attaque normale
                        if (!this.isAttacking) {
                            this.comboType = 'normal';
                            this.comboGCounter = 0; // Reset combo G
                            this.attack();
                            console.log(`üëä ${this.type}: ATTAQUE NORMALE I!`);
                        }
                    }
                }
            }
            
            // ü•ä GATLING ATTACK - Multi-coups rapides avec endurance !
            startGatlingAttack() {
                if (this.gatlingPhase > 0) return; // D√©j√† en cours
                
                // üîã V√©rifier l'endurance minimum requise pour d√©marrer
                const minStaminaRequired = 10; // Endurance minimum pour d√©marrer
                if (this.stamina < minStaminaRequired) {
                    console.log(`‚ùå ${this.type}: Endurance insuffisante pour Gatling (${this.stamina.toFixed(1)}/${minStaminaRequired})`);
                    return;
                }
                
                console.log(`üî•ü•ä ${this.type}: GATLING ATTACK - PR√âPARATION (3 secondes)!`);
                
                this.isGatling = true;
                this.gatlingPhase = 1; // Phase d'enclenchement
                this.gatlingCurrentFrame = 1;
                this.gatlingFrameTimer = 0; // FORCER √† z√©ro
                this.gatlingCount = 0;
                this.gatlingDamage = 15; // D√©g√¢ts par coup
                this.gatlingStartTime = Date.now(); // Chronom√®tre pour mesurer la dur√©e
                this.gatlingLastFrameTime = null; // Nouveau syst√®me temps r√©el
                
                console.log(`üîÑ SYST√àME GATLING TEMPS R√âEL initialis√© - D√©but: ${this.gatlingStartTime}`);
                
                // ‚ùå NE PAS set isAttacking=true pendant la pr√©paration!
                // this.isAttacking sera activ√© seulement en phase d'attaque (frame 6+)
                this.animationState = 'gatling';
                this.animationFrame = 1;
                
                console.log(`ÔøΩ Phase 1: PR√âPARATION DRAMATIQUE (frames 1-5, 1000ms/frame) - L'adversaire a le temps de voir venir!`);
            }
            
            // Arr√™ter le gatling
            stopGatlingAttack() {
                if (this.isGatling) {
                    console.log(`üî• ${this.type}: Gatling TERMIN√â! Total coups: ${this.gatlingCount}`);
                    this.isGatling = false;
                    this.isAttacking = false;
                    
                    // üîß FORCER le retour √† idle1 et r√©initialiser le syst√®me d'animation
                    this.animationState = 'idle';
                    this.animationFrame = 1;
                    this.animationTimer = 0; // R√©initialiser le timer d'animation
                    
                    this.gatlingPhase = 0;
                    this.gatlingCurrentFrame = 1;
                    this.gatlingFrameTimer = 0;
                    this.gatlingCount = 0;
                    this.gatlingLastFrameTime = null; // Nettoyer le syst√®me temps r√©el
                    
                    console.log(`üîÑ Animation reset: state=idle, frame=1, timer=0`);
                }
            }
            
            // ‚öîÔ∏è WARRIOR COMBO 3-HIT - SIMPLE COMME ATTAQUE NORMALE
            startWarriorCombo() {
                if (this.isCombo) return; // D√©j√† en combo
                
                console.log(`‚öîÔ∏èüî• ${this.type}: WARRIOR COMBO HIT ${this.comboHitCount + 1}/3 ACTIV√â!`);
                
                this.isCombo = true;
                this.comboTimer = 0;
                this.currentHitDealt = false; // Reset pour ce coup
                this.animationState = 'combo';
                this.isAttacking = true;
                this.lastComboTime = Date.now(); // Temps du dernier coup pour la fen√™tre
                
                console.log(`‚öîÔ∏è Coup ${this.comboHitCount + 1} d√©marr√© - ${this.comboDuration}s`);
            }
            
            // Terminer le coup actuel et pr√©parer le suivant
            finishCurrentComboHit() {
                this.comboHitCount++;
                this.isCombo = false;
                this.isAttacking = false;
                this.comboTimer = 0;
                this.animationState = 'idle';
                this.animationFrame = 1;
                
                console.log(`‚öîÔ∏è Coup ${this.comboHitCount}/3 termin√©. Fen√™tre d'encha√Ænement: ${this.comboWindow}ms`);
                
                // Si c'√©tait le 3√®me coup, reset compl√®tement
                if (this.comboHitCount >= 3) {
                    this.resetCombo();
                }
            }
            
            // Reset complet du combo
            resetCombo() {
                console.log(`üîÑ COMBO RESET - ${this.comboHitCount}/3 coups r√©alis√©s`);
                this.comboHitCount = 0;
                this.lastComboTime = 0;
            }
            
            // Arr√™ter le combo warrior
            stopWarriorCombo() {
                if (this.isCombo) {
                    this.isCombo = false;
                    this.isAttacking = false;
                    this.comboTimer = 0;
                    this.comboHitCount = 0;
                    this.animationState = 'idle';
                    this.animationFrame = 1;
                }
            }
            
            // Ex√©cuter un coup de combo
            performComboHit(hitNumber) {
                // V√©rifier si on touche l'adversaire
                const opponent = this.isPlayer1 ? players[1] : players[0];
                if (opponent && this.checkCollision(opponent)) {
                    // üì≥ SCREEN SHAKE seulement sur vraie collision !
                    startScreenShake(150, 8);
                    
                    // üî• EFFET D'IMPACT seulement sur collision
                    const attackX = this.x + (this.facingLeft ? -25 : this.width + 25);
                    const attackY = this.y + this.height/2 - 10;
                    impactEffects.push(new ImpactEffect(attackX, attackY, 'hit', 250));
                    
                    // D√©g√¢ts progressifs : Hit 1=12, Hit 2=15, Hit 3=18
                    const progressiveDamage = this.comboDamage + (hitNumber - 1) * 3;
                    opponent.takeDamage(progressiveDamage, this);
                    this.comboHitCount++;
                    
                    console.log(`‚öîÔ∏è Combo hit ${hitNumber} sur ${opponent.type}! D√©g√¢ts: ${progressiveDamage}`);
                    
                    // Effet de knockback selon le coup
                    if (hitNumber === 3) {
                        // Coup final = knockback plus fort
                        const knockbackForce = this.facingLeft ? -350 : 350;
                        opponent.vx = knockbackForce;
                        opponent.vy = -200; // L√©ger soul√®vement
                        console.log(`üí• COUP FINAL! Knockback: ${knockbackForce}`);
                    } else {
                        // Coups interm√©diaires = petit stun
                        const smallKnockback = this.facingLeft ? -150 : 150;
                        opponent.vx = smallKnockback;
                    }
                    
                    // Son diff√©rent selon le coup
                    if (hitNumber === 3) {
                        playExplosiveHit(); // Son de coup final explosif
                    } else {
                        playMeatyPunch(progressiveDamage); // Son de coup interm√©diaire
                    }
                } else {
                    console.log(`üí® Combo hit ${hitNumber} dans le vide`);
                    playWhooshSound(); // Son de coup qui rate
                }
            }
            
            // Effet visuel pour le gatling
            createGatlingEffect() {
                // Effets de particules supprim√©s
            }
            
            // Ex√©cuter un coup de gatling
            performGatlingHit() {
                console.log(`üí• Gatling hit ${this.gatlingCount}/${this.gatlingMaxHits}`);
                
                // üì≥ SCREEN SHAKE sur chaque coup !
                startScreenShake(100, 5); // 100ms, intensit√© 5
                
                // Cr√©er des particules d'impact
                this.createGatlingEffect();
                
                // ÔøΩ EFFET D'IMPACT pour chaque coup de Gatling (m√™me dans le vide)
                const attackX = this.x + (this.facingLeft ? -20 : this.width + 20);
                const attackY = this.y + this.height/2;
                impactEffects.push(new ImpactEffect(attackX, attackY, 'hit', 200));
                
                // ÔøΩüö´ NE PLUS override this.animationFrame - laisser le syst√®me Gatling g√©rer
                
                // V√©rifier si on touche l'adversaire
                const opponent = this.isPlayer1 ? players[1] : players[0];
                if (opponent && this.checkCollision(opponent)) {
                    opponent.takeDamage(this.gatlingDamage, this);
                    console.log(`ü•ä Gatling hit sur ${opponent.type}!`);
                    
                    // ÔøΩ IMPACT EFFECTS pour Gatling!
                    const impactX = opponent.x + opponent.width/2;
                    const impactY = opponent.y + opponent.height/3;
                    
                    // Effet d'impact principal
                    impactEffects.push(new ImpactEffect(impactX, impactY, 'hit', 300));
                    
                    // Effets multiples al√©atoires pour style "ORA ORA"
                    const randomOffsetX = (Math.random() - 0.5) * 40;
                    const randomOffsetY = (Math.random() - 0.5) * 30;
                    impactEffects.push(new ImpactEffect(impactX + randomOffsetX, impactY + randomOffsetY, 'critical', 250));
                    
                    // ÔøΩüì≥ SCREEN SHAKE plus fort quand on touche !
                    startScreenShake(200, 8);
                }
            }
            
            // D√©tection de collision pour les joueurs
            checkCollision(other) {
                const hitboxPadding = 5; // R√©duit de 20 √† 5 pour une port√©e plus r√©aliste
                const myLeft = this.x - hitboxPadding;
                const myRight = this.x + this.width + hitboxPadding;
                const myTop = this.y;
                const myBottom = this.y + this.height;
                
                const otherLeft = other.x;
                const otherRight = other.x + other.width;
                const otherTop = other.y;
                const otherBottom = other.y + other.height;
                
                return myLeft < otherRight && myRight > otherLeft &&
                       myTop < otherBottom && myBottom > otherTop;
            }
            
            attack() {
                // V√©rifier si c'est une contre-attaque
                const isCounterAttack = this.counterOpportunity > 0;
                
                this.isAttacking = true;
                this.attackTimer = 0;
                this.hasHit = false;
                
                // Si c'est une contre-attaque, on l'utilise
                if (isCounterAttack) {
                    this.counterOpportunity = 0; // Consommer l'opportunit√©
                    this.isCounterAttacking = true;
                    console.log(`${this.type}: CONTRE-ATTAQUE !`);
                    this.debugText = "COUNTER!";
                    this.debugTimer = 60;
                }
                
                // D√©finir l'√©tat d'animation selon le type de combo
                switch(this.comboType) {
                    case 'uppercut':
                        this.animationState = 'uppercut';
                        this.attackDuration = isCounterAttack ? 400 : 700; // Counter plus rapide
                        console.log(`${this.type}: Animation UPPERCUT ${isCounterAttack ? '(COUNTER)' : ''} activ√©e!`);
                        // Debug visible √† l'√©cran
                        this.debugText = isCounterAttack ? "COUNTER UPPERCUT!" : "UPPERCUT!";
                        this.debugTimer = 60;
                        break;
                    case 'low':
                        this.animationState = 'low';
                        this.attackDuration = isCounterAttack ? 350 : 600; // Counter plus rapide
                        console.log(`${this.type}: Animation LOW ${isCounterAttack ? '(COUNTER)' : ''} activ√©e!`);
                        // Debug visible √† l'√©cran
                        this.debugText = isCounterAttack ? "COUNTER LOW!" : "LOW ATTACK!";
                        this.debugTimer = 60;
                        break;
                    case 'double':
                        this.animationState = 'double';
                        this.attackDuration = isCounterAttack ? 450 : 800; // Counter plus rapide
                        console.log(`${this.type}: Animation DOUBLE ${isCounterAttack ? '(COUNTER)' : ''} activ√©e!`);
                        // Debug visible √† l'√©cran
                        this.debugText = isCounterAttack ? "COUNTER DOUBLE!" : "DOUBLE HIT!";
                        this.debugTimer = 60;
                        break;
                    default:
                        this.animationState = 'attack';
                        this.attackDuration = isCounterAttack ? 300 : 500; // Counter plus rapide
                        console.log(`${this.type}: Animation ATTACK ${isCounterAttack ? '(COUNTER)' : ''} normale`);
                        // Debug visible √† l'√©cran
                        this.debugText = isCounterAttack ? "COUNTER ATTACK!" : "NORMAL ATTACK";
                        this.debugTimer = 60;
                }
                
                // Reset de l'animation
                this.animationFrame = 1;
            }
            
            takeDamage(amount, attackerX = null, knockdownType = null, attacker = null) {
                // V√©rifier perfect dodge (invincibilit√© temporaire)
                if (this.perfectDodgeInvincible) {
                    console.log(`${this.type} : Perfect dodge ! Invuln√©rable !`);
                    // Particules de poussi√®re supprim√©es
                    return "perfect_dodge";
                }

                // V√©rifier si l'attaque est bloqu√©e
                if (this.isBlocking && attackerX !== null) {
                    // D√©terminer la direction de l'attaque
                    const attackFromLeft = attackerX < this.x;
                    const attackFromRight = attackerX > this.x;
                    
                    // V√©rifier si la garde est dans la bonne direction
                    const guardingCorrectDirection = 
                        (attackFromLeft && this.blockDirection < 0) || 
                        (attackFromRight && this.blockDirection > 0);
                    
                    if (guardingCorrectDirection) {
                        // V√©rifier perfect parry
                        const isPerfectParry = this.perfectBlockTimer > 0;
                        
                        if (isPerfectParry) {
                            // Perfect parry : aucun d√©g√¢t, stun l'attaquant et permet un contre
                            console.log(`${this.type} : PERFECT PARRY ! Contre disponible !`);
                            // Particules d'√©tincelles supprim√©es
                            this.counterOpportunity = this.counterWindow;
                            
                            // Stun l'attaquant si disponible
                            if (attacker) {
                                attacker.blockStun = 30; // L'attaquant est stunn√©
                            }
                            
                            return "perfect_parry";
                        } else {
                            // Block normal
                            this.blockStun = this.blockStunDuration;
                            this.health -= Math.floor(amount * 0.2); // 20% des d√©g√¢ts
                            this.health = Math.max(0, this.health);
                            
                            // Incr√©menter le compteur de garde
                            this.guardPressure++;
                            
                            // V√©rifier guard break
                            if (this.guardPressure >= this.guardBreakThreshold) {
                                this.triggerGuardBreak();
                                console.log(`${this.type} : GARDE CASS√âE !`);
                                return "guard_break";
                            }
                            
                            // Petit recul lors du block
                            const pushback = attackFromLeft ? 50 : -50;
                            this.vx = pushback;
                            
                            console.log(`${this.type} : Attaque bloqu√©e ! Garde: ${this.guardPressure}/${this.guardBreakThreshold}`);
                            
                            // üéµ SON DE BLOCK M√âTALLIQUE !
                            playImpactSound(amount, true, false);
                            
                            return "blocked";
                        }
                    }
                }
                
                // Attaque non bloqu√©e - d√©g√¢ts normaux
                this.health -= amount;
                this.health = Math.max(0, this.health);
                
                // ü•ä FREEZE FRAME BAS√â SUR LES D√âG√ÇTS !
                const freezeDuration = Math.min(200, amount * 4); // Max 200ms, 4ms par point de d√©g√¢t
                const useFlash = amount >= 25; // Flash blanc pour les gros coups
                triggerFreezeFrame(freezeDuration, useFlash, 80);
                
                // Screen shake proportionnel aux d√©g√¢ts
                applyScreenShake(amount * 0.8);
                
                console.log(`ü•ä IMPACT! D√©g√¢ts: ${amount} ‚Üí Freeze: ${freezeDuration}ms ${useFlash ? '+ Flash' : ''}`);
                
                // üéµ SON D'IMPACT JUTEUX !
                playImpactSound(amount, false, useFlash);
                
                // üí• IMPACT STYLE TEKKEN !
                createImpactBurst(this.x + this.width/2, this.y + this.height/2, 'impact');
                
                // Arr√™ter la garde si on prend des d√©g√¢ts
                this.stopBlocking();
                
                // Reset guard pressure apr√®s avoir pris des d√©g√¢ts
                this.guardPressure = 0;
                
                // V√©rifier si c'est une attaque a√©rienne qui touche
                if (this.isAirborne && knockdownType !== 'air') {
                    // Forcer un air knockdown
                    knockdownType = 'air';
                }
                
                // Ne pas forcer l'√©tat hurt si on est d√©j√† knockdown
                // Le knockdown aura priorit√© sur l'animation hurt
                if (!this.isDown) {
                    // √âtat de hurt plus long et visible
                    this.animationState = 'hurt';
                    this.animationFrame = 1;
                    this.hurtTimer = 800; // Dur√©e d'√©tat hurt (800ms)
                    this.isHurt = true;
                }
                
                // Interruption des actions en cours (sauf air attack)
                if (!this.isAirAttacking) {
                    this.isAttacking = false;
                }
                this.isChargingSpecial = false;
                this.isDashing = false;
                
                // Annuler perfect dodge si touch√©
                this.perfectDodgeInvincible = false;
                
                console.log(`${this.type} : D√©g√¢ts subis ! HP: ${this.health}`);
                return "hit"; // Attaque r√©ussie
            }
            
            /**
             * Ajuste automatiquement la taille du sprite si il d√©passe les limites
             * @param {HTMLImageElement} sprite - L'image du sprite
             * @returns {Object} - Dimensions ajust√©es {width, height}
             */
            getAdjustedSpriteDimensions(sprite) {
                if (!sprite) return { width: this.width, height: this.height };
                
                let renderWidth = this.width;
                let renderHeight = this.height;
                
                // Taille standardis√©e pour tous les personnages
                if (this.type.toLowerCase().includes('ninja') || this.type.toLowerCase().includes('warrior')) {
                    renderWidth = 100;
                    renderHeight = 100;
                }
                
                // V√©rifier si le sprite d√©passe les limites du canvas
                const spriteRight = this.x + renderWidth;
                const spriteBottom = this.y + renderHeight;
                
                // Ajuster si n√©cessaire
                if (spriteRight > canvas.width) {
                    const scale = canvas.width / spriteRight;
                    renderWidth *= scale;
                    renderHeight *= scale;
                }
                
                if (spriteBottom > canvas.height) {
                    const scale = canvas.height / spriteBottom;
                    renderWidth *= scale;
                    renderHeight *= scale;
                }
                
                return { width: renderWidth, height: renderHeight };
            }
            
            render(ctx) {
                // Obtenir le sprite - UTILISER animationFrame mis √† jour par le combo
                const currentFrame = this.animationFrame;
                const sprite = getSprite(this.animationState, currentFrame, this.type);
                
                console.log(`üîç DEBUG RENDER: type=${this.type}, state=${this.animationState}, frame=${currentFrame}, isCombo=${this.isCombo}`);
                
                // Debug pour Gatling - IDENTIFI√â PAR JOUEUR
                if (this.isGatling && this.gatlingPhase > 0) {
                    console.log(`üé¨ ${this.type} RENDER GATLING: state=${this.animationState}, gatlingFrame=${this.gatlingCurrentFrame}, phase=${this.gatlingPhase}, stamina=${this.stamina.toFixed(1)}`);
                }
                
                // Debug pour Combo
                if (this.isCombo) {
                    console.log(`‚öîÔ∏è ${this.type} RENDER COMBO: state=${this.animationState}, frame=${this.animationFrame}, timer=${this.comboTimer.toFixed(2)}s, hits=${this.comboHitCount}`);
                }
                
                if (sprite) {
                    ctx.save();
                    
                    // Effets visuels de garde supprim√©s
                    
                    // Taille standardis√©e pour tous les sprites ninja
                    let renderWidth = this.width;
                    let renderHeight = this.height;
                    
                    if (this.type.toLowerCase().includes('ninja') || this.type.toLowerCase().includes('warrior')) {
                        // Forcer une taille constante pour tous les sprites
                        renderWidth = 100;  // Taille fixe largeur (agrandie)
                        renderHeight = 100; // Taille fixe hauteur (agrandie)
                    }
                    
                    if (this.facingLeft) {
                        ctx.scale(-1, 1);
                        ctx.drawImage(sprite, -this.x - renderWidth, this.y, renderWidth, renderHeight);
                    } else {
                        ctx.drawImage(sprite, this.x, this.y, renderWidth, renderHeight);
                    }
                    ctx.restore();
                    
                    // Rendu des particules supprim√©
                } else {
                    // Fallback rectangle
                    ctx.fillStyle = this.isPlayer1 ? 'blue' : 'red';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // Indicateur sprite manquant
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${this.animationState}${this.animationFrame}`, this.x + this.width/2, this.y + this.height/2);
                }
                
                // Affichage debug combo
                if (this.debugTimer > 0) {
                    ctx.save();
                    ctx.fillStyle = 'yellow';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.strokeText(this.debugText, this.x + this.width/2, this.y - 30);
                    ctx.fillText(this.debugText, this.x + this.width/2, this.y - 30);
                    
                    this.debugTimer -= 16.67; // ~60fps
                    if (this.debugTimer <= 0) {
                        this.debugText = "";
                    }
                }
                
                // Effet visuel de garde supprim√©
                
                // Effet visuel de dash supprim√©
                
                // Cooldown indicators
                ctx.save();
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                
                // Dash cooldown
                if (this.dashCooldown > 0) {
                    const dashPercent = (this.dashCooldown / this.dashCooldownDuration * 100).toFixed(0);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillText(`D: ${dashPercent}%`, this.x + this.width/2, this.y - 5);
                }
                
                // Block stun
                if (this.blockStun > 0) {
                    const stunPercent = (this.blockStun / this.blockStunDuration * 100).toFixed(0);
                    ctx.fillStyle = '#FF0000';
                    ctx.fillText(`STUN: ${stunPercent}%`, this.x + this.width/2, this.y + this.height + 15);
                }
                
                ctx.restore();
                
                // Barre de vie
                const barWidth = 60;
                const barHeight = 8;
                const barX = this.x + (this.width - barWidth) / 2;
                const barY = this.y - 30; // Juste au-dessus de la t√™te
                
                ctx.fillStyle = 'red';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                ctx.fillStyle = 'green';
                const healthWidth = (this.health / this.maxHealth) * barWidth;
                ctx.fillRect(barX, barY, healthWidth, barHeight);
                
                ctx.strokeStyle = 'white';
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // üí™ Barre d'endurance (sous la barre de vie)
                const staminaBarY = barY + barHeight + 2; // 2px d'espacement
                
                ctx.fillStyle = 'orange'; // Fond orange fonc√©
                ctx.fillRect(barX, staminaBarY, barWidth, barHeight);
                
                // Couleur dynamique selon le niveau d'endurance
                const staminaPercent = this.stamina / this.maxStamina;
                if (staminaPercent < 0.25) {
                    ctx.fillStyle = 'red'; // Rouge si < 25%
                } else if (staminaPercent < 0.5) {
                    ctx.fillStyle = 'orange'; // Orange si < 50%
                } else {
                    ctx.fillStyle = 'yellow'; // Jaune normal
                }
                
                const staminaWidth = staminaPercent * barWidth;
                ctx.fillRect(barX, staminaBarY, staminaWidth, barHeight);
                
                ctx.strokeStyle = 'white';
                ctx.strokeRect(barX, staminaBarY, barWidth, barHeight);
                
                // Debug visuel pour les √©tats sp√©ciaux
                if (this.isDown) {
                    ctx.save();
                    ctx.fillStyle = 'red';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.strokeText(`DOWN! ${Math.ceil(this.downTimer/1000)}s`, this.x + this.width/2, this.y - 50);
                    ctx.fillText(`DOWN! ${Math.ceil(this.downTimer/1000)}s`, this.x + this.width/2, this.y - 50);
                    ctx.restore();
                }
                
                if (this.isGettingUp) {
                    ctx.save();
                    ctx.fillStyle = 'orange';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.strokeText(`GETTING UP! ${Math.ceil(this.getupTimer/1000)}s`, this.x + this.width/2, this.y - 25);
                    ctx.fillText(`GETTING UP! ${Math.ceil(this.getupTimer/1000)}s`, this.x + this.width/2, this.y - 25);
                    ctx.restore();
                }
                
                // Indicateur phase sp√©ciale
                if (this.isChargingSpecial) {
                    ctx.save();
                    ctx.fillStyle = 'cyan';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Phase ${this.specialPhase}`, this.x + this.width/2, this.y - 30);
                    ctx.restore();
                }
                
                // üé≠ Affichage simplifi√© des animations de victoire/d√©faite
                if (this.isInVictoryPose) {
                    ctx.save();
                    ctx.fillStyle = 'gold';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    const text = 'ÔøΩ WIN!';
                    ctx.strokeText(text, this.x + this.width/2, this.y - 60);
                    ctx.fillText(text, this.x + this.width/2, this.y - 60);
                    ctx.restore();
                }
                
                if (this.isInDefeatPose) {
                    ctx.save();
                    ctx.fillStyle = 'darkred';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    const text = 'üíÄ K.O.';
                    ctx.strokeText(text, this.x + this.width/2, this.y - 60);
                    ctx.fillText(text, this.x + this.width/2, this.y - 60);
                    ctx.restore();
                }
            }
            
            // üé≠ NOUVELLES M√âTHODES POUR ANIMATIONS DE VICTOIRE/D√âFAITE
            startVictoryPose() {
                console.log(`üéâ ${this.type} - D√©but animation de VICTOIRE !`);
                this.isInVictoryPose = true;
                this.isInDefeatPose = false;
                this.animationState = 'victory';
                this.animationFrame = 1;
                this.victoryAnimationTimer = 0;
                this.isAttacking = false;
                this.isGatling = false;
                this.isCombo = false;
                this.isBlocking = false;
                this.isDown = false;
                this.isGettingUp = false;
                this.vx = 0;
                this.vy = 0;
            }
            
            startDefeatPose() {
                console.log(`üò¢ ${this.type} - D√©but animation de D√âFAITE !`);
                this.isInDefeatPose = true;
                this.isInVictoryPose = false;
                this.animationState = 'defeat';
                this.animationFrame = 1;
                this.defeatAnimationTimer = 0;
                this.isAttacking = false;
                this.isGatling = false;
                this.isCombo = false;
                this.isBlocking = false;
                this.isDown = false;
                this.isGettingUp = false;
                this.vx = 0;
                this.vy = 0;
            }
            
            stopVictoryDefeatPoses() {
                console.log(`üîÑ ${this.type} - Fin des animations victoire/d√©faite`);
                this.isInVictoryPose = false;
                this.isInDefeatPose = false;
                this.animationState = 'idle';
                this.animationFrame = 1;
                this.victoryAnimationTimer = 0;
                this.defeatAnimationTimer = 0;
            }
            
            // ‚öîÔ∏è NOUVELLES M√âTHODES POUR COMBAT AVANC√â
            
            startPerfectBlock() {
                if (!this.isBlocking) return false;
                
                this.isPerfectBlocking = true;
                this.perfectBlockTimer = this.perfectBlockWindow;
                this.canCounter = true;
                this.counterTimer = this.counterWindow;
                
                console.log(`üõ°Ô∏è ${this.type}: PERFECT BLOCK activ√©! Window: ${this.perfectBlockWindow}ms`);
                
                // Effet visuel de parade parfaite
                // Particules d'√©tincelles supprim√©es
                return true;
            }
            
            attemptCounter(opponent) {
                if (!this.canCounter) return false;
                
                console.log(`‚öîÔ∏è ${this.type}: COUNTER ATTACK!`);
                this.canCounter = false;
                
                // Contre-attaque automatique avec bonus d√©g√¢ts
                this.attack();
                this.isCounterAttacking = true;
                this.counterDamageBonus = 1.5; // 50% de d√©g√¢ts en plus
                
                // Effet visuel sp√©cial pour contre
                // Particules d'impact supprim√©es
                
                return true;
            }
            
            checkGuardBreak() {
                this.currentBlockCount++;
                console.log(`üõ°Ô∏è ${this.type}: Block count: ${this.currentBlockCount}/${this.guardBreakThreshold}`);
                
                if (this.currentBlockCount >= this.guardBreakThreshold) {
                    this.isGuardBroken = true;
                    this.guardBreakTimer = this.guardBreakDuration;
                    this.isBlocking = false;
                    this.currentBlockCount = 0;
                    
                    console.log(`üí• ${this.type}: GUARD BROKEN! Vulnerable for ${this.guardBreakDuration}ms`);
                    
                    // Effet visuel de garde cass√©e
                    // Particules d'impact supprim√©es
                    startScreenShake(500, 8);
                    
                    return true;
                }
                return false;
            }
            
            startAirAttack() {
                if (!this.onGround && this.canAirAttack && !this.isAirAttacking) {
                    this.isAirAttacking = true;
                    this.airAttackTimer = this.airAttackDuration;
                    this.animationState = 'attack';
                    this.animationFrame = 1;
                    
                    console.log(`ü¶Ö ${this.type}: AIR ATTACK! Combo: ${this.airComboCount}/${this.maxAirCombo}`);
                    
                    // Particules d'attaque a√©rienne
                    // Particules d'√©tincelles supprim√©es
                    return true;
                }
                return false;
            }
            
            startPerfectDodge(direction) {
                // D√©marrer le dash avec perfect dodge
                this.startDash(direction);
                
                // Activer l'invincibilit√© imm√©diatement
                this.perfectDodgeInvincible = true;
                
                console.log(`üëª ${this.type}: PERFECT DODGE! Invincible pendant le dash!`);
                
                // Effet visuel d'esquive parfaite
                // Particules de poussi√®re supprim√©es
                return true;
            }

            // ========== M√âTHODES DE COMBAT AVANC√â ==========
            
            triggerGuardBreak() {
                this.isGuardBroken = true;
                this.guardBreakTimer = this.guardBreakDuration;
                this.guardPressure = 0; // Reset la pression
                this.stopBlocking(); // Arr√™ter la garde
                
                // Effet visuel de garde cass√©e
                // Particules d'impact supprim√©es
                
                console.log(`üíî ${this.type}: GUARD BREAK! Vuln√©rable pendant ${this.guardBreakDuration}ms`);
            }

            checkGuardBreak() {
                return this.guardPressure >= this.guardBreakThreshold;
            }

            // ü§ñ IA SIMPLE POUR TESTS
            simpleAI(deltaTime) {
                const opponent = players[0]; // Player 1
                const distance = Math.abs(this.x - opponent.x);
                
                // Timer global d'IA
                aiTimer += deltaTime;
                
                if (!this.isAttacking && !this.isHurt && !this.isDown && !this.isGettingUp) {
                    // Se rapprocher si trop loin
                    if (distance > 80) {
                        if (opponent.x < this.x) {
                            this.vx = -this.speed * 0.8;
                            this.facingLeft = true;
                        } else {
                            this.vx = this.speed * 0.8;
                            this.facingLeft = false;
                        }
                    }
                    // Attaquer si √† port√©e et pas d'attaque r√©cente
                    else if (distance < 70 && aiTimer > 1500) {
                        aiTimer = 0; // Reset timer
                        
                        // Choisir une attaque al√©atoire
                        const attackChoice = Math.random();
                        if (attackChoice < 0.6) {
                            // Attaque normale (60%)
                            this.handleComboAttack();
                            console.log("ü§ñ IA: Attaque normale");
                        } else if (attackChoice < 0.8) {
                            // Uppercut (20%)
                            this.comboType = 'uppercut';
                            this.handleComboAttack();
                            console.log("ü§ñ IA: Uppercut");
                        } else {
                            // Low attack (20%)
                            this.comboType = 'low';
                            this.handleComboAttack();
                            console.log("ü§ñ IA: Low attack");
                        }
                    }
                    // Bloquer si l'adversaire attaque
                    else if (opponent.isAttacking && distance < 80 && Math.random() < 0.7) {
                        const guardDirection = this.facingLeft ? -1 : 1;
                        this.startBlocking(guardDirection);
                        console.log("ü§ñ IA: Garde!");
                    }
                }
            }

            // ========== M√âTHODES DE G√âN√âRATION DE PARTICULES ==========
            
            // M√©thodes de cr√©ation de particules supprim√©es

            // M√©thode de cr√©ation de particules supprim√©e
        }

        // ========== FONCTIONS UTILITAIRES POUR LA GESTION DES SPRITES ==========
        
        /**
         * Fonction pour dessiner un sprite avec gestion automatique du recadrage
         * @param {CanvasRenderingContext2D} ctx - Contexte du canvas
         * @param {HTMLImageElement} image - Image du sprite
         * @param {number} x - Position X
         * @param {number} y - Position Y
         * @param {number} width - Largeur souhait√©e
         * @param {number} height - Hauteur souhait√©e
         */
        function drawSpriteWithClipping(ctx, image, x, y, width, height) {
            if (!image || !image.complete) return;
            
            // Calculer les zones visibles
            const visibleX = Math.max(0, x);
            const visibleY = Math.max(0, y);
            const visibleRight = Math.min(canvas.width, x + width);
            const visibleBottom = Math.min(canvas.height, y + height);
            
            // Si le sprite est compl√®tement hors de l'√©cran, ne pas le dessiner
            if (visibleX >= visibleRight || visibleY >= visibleBottom) return;
            
            // Calculer les offsets pour le sprite source
            const sourceX = (visibleX - x) / width * image.width;
            const sourceY = (visibleY - y) / height * image.height;
            const sourceWidth = (visibleRight - visibleX) / width * image.width;
            const sourceHeight = (visibleBottom - visibleY) / height * image.height;
            
            // Dessiner la partie visible du sprite
            ctx.drawImage(
                image,
                sourceX, sourceY, sourceWidth, sourceHeight,
                visibleX, visibleY, visibleRight - visibleX, visibleBottom - visibleY
            );
        }
        
        /**
         * Fonction pour ajuster automatiquement les dimensions de sprite
         * @param {number} originalWidth - Largeur originale du sprite
         * @param {number} originalHeight - Hauteur originale du sprite
         * @param {number} maxWidth - Largeur maximum autoris√©e
         * @param {number} maxHeight - Hauteur maximum autoris√©e
         * @returns {Object} - Nouvelles dimensions {width, height}
         */
        function getOptimalSpriteDimensions(originalWidth, originalHeight, maxWidth, maxHeight) {
            const widthRatio = maxWidth / originalWidth;
            const heightRatio = maxHeight / originalHeight;
            const scale = Math.min(widthRatio, heightRatio, 1); // Ne pas agrandir
            
            return {
                width: Math.floor(originalWidth * scale),
                height: Math.floor(originalHeight * scale)
            };
        }
        
        /**
         * Fonction pour cr√©er une zone de s√©curit√© autour des sprites
         * @param {number} x - Position X du sprite
         * @param {number} y - Position Y du sprite
         * @param {number} width - Largeur du sprite
         * @param {number} height - Hauteur du sprite
         * @param {number} margin - Marge de s√©curit√©
         * @returns {Object} - Position ajust√©e {x, y}
         */
        function applySafeZone(x, y, width, height, margin = 10) {
            return {
                x: Math.max(-margin, Math.min(canvas.width - width + margin, x)),
                y: Math.max(-margin, Math.min(canvas.height - height + margin, y))
            };
        }

        function init() {
            players = [
                new FixedPlayer(200, 620, 'Warrior', true),     // üó°Ô∏è WARRIOR √Ä GAUCHE !
                new FixedPlayer(900, 620, 'Ninja Red', false)   // ü•∑ NINJA √Ä DROITE !
            ];
            
            // ü•ä Initialiser le syst√®me de rounds
            roundSystem.roundStartTime = Date.now();
            console.log(`ü•ä D√âBUT DU ROUND ${roundSystem.currentRound}`);
            console.log(`üìä Premier √† 3 victoires remporte le match !`);
            console.log(`‚öîÔ∏è WARRIOR vs NINJA - COMBAT CLASSIQUE 1v1 !`);
            
            requestAnimationFrame(gameLoop);
        }

        let lastTime = 0;
        function gameLoop(currentTime) {
            if (!gameRunning) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Mettre √† jour le temps pour les animations du dojo
            time = currentTime * 0.001; // Convertir en secondes
            
            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            // üéÆ GESTION DES STATES DU JEU
            if (gameState === 'characterSelect') {
                updateCharacterSelect(deltaTime);
                return;
            }
            
            // ü•ä GESTION DU FREEZE FRAME (doit √™tre en premier)
            const freezeMultiplier = updateFreezeFrame(deltaTime);
            const effectiveDelta = deltaTime * timeScale * freezeMultiplier;
            
            // üé¨ MISE √Ä JOUR DE LA CAM√âRA DYNAMIQUE
            updateSpecialCamera();
            
            // üé¨ MISE √Ä JOUR DU CINEMATIC ZOOM (Tekken-style)
            updateCinematicZoom();
            
            // Si on est en freeze frame, on arr√™te les updates
            if (freezeMultiplier === 0.0) {
                console.log(`ü•ä FREEZE ACTIF - Pas d'update`);
                return; // Tout s'arr√™te pendant le freeze !
            }
            
            for (const player of players) {
                player.update(effectiveDelta);
            }
            
            // üí• MISE √Ä JOUR DES PARTICULES STYLE TEKKEN
            particles = particles.filter(particle => particle.update(effectiveDelta));
            
            // ü•ä GESTION DU SYST√àME DE ROUNDS
            updateRoundSystem(effectiveDelta);
            
            // Mettre √† jour les effets d'impact
            for (let i = impactEffects.length - 1; i >= 0; i--) {
                const effect = impactEffects[i];
                if (!effect.update(effectiveDelta / 1000)) {
                    impactEffects.splice(i, 1);
                }
            }
            
            // Mettre √† jour les effets de lumi√®re de combat

            
            // Mettre √† jour le screen shake
            if (screenShake.duration > 0) {
                screenShake.duration -= effectiveDelta;
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                
                if (screenShake.duration <= 0) {
                    screenShake.x = 0;
                    screenShake.y = 0;
                }
            }
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                
                if (!projectile.update(deltaTime)) {
                    projectiles.splice(i, 1);
                    continue;
                }
                
                for (const player of players) {
                    if (projectile.owner !== player && projectile.checkCollision(player)) {
                        const wasBlocked = player.takeDamage(projectile.damage, projectile.x);
                        
                        if (!wasBlocked) {
                            player.vx = projectile.direction * 120; // R√©duit de 200 √† 120
                        }
                        
                        // Effets d'impact spectaculaires pour l'attaque sp√©ciale !
                        const impactX = player.x + player.width/2;
                        const impactY = player.y + player.height/2;
                        
                        // Explosion principale massive
                        impactEffects.push(new ImpactEffect(impactX, impactY, 'special_explosion', 1000));
                        
                        // Multiples impacts secondaires pour effet dramatique
                        setTimeout(() => {
                            impactEffects.push(new ImpactEffect(impactX - 30, impactY - 20, 'critical', 600));
                            impactEffects.push(new ImpactEffect(impactX + 25, impactY + 15, 'critical', 700));
                        }, 100);
                        
                        setTimeout(() => {
                            impactEffects.push(new ImpactEffect(impactX - 15, impactY + 30, 'hit', 400));
                            impactEffects.push(new ImpactEffect(impactX + 20, impactY - 25, 'hit', 500));
                        }, 250);
                        
                        // Screen shake ultra intense
                        screenShake = { x: 0, y: 0, intensity: 20, duration: 800 };
                        
                        console.log(`üí• SPECIAL IMPACT on ${player.type}!`);
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
            
            const [p1, p2] = players;
            const distance = Math.abs(p1.x - p2.x);
            
            if (distance < 60) { // R√©duit de 100 √† 60 pixels pour une port√©e plus r√©aliste
                if (p1.isAttacking && !p1.hasHit && p1.animationFrame >= 2) {
                    // V√©rifier que p1 attaque dans la bonne direction ET √† bonne port√©e
                    const attackRange = p1.isAirAttacking ? 70 : 50; // Plus de port√©e en l'air
                    let canHit = false;
                    
                    if (p1.facingLeft && p2.x < p1.x) {
                        // Attaque vers la gauche
                        canHit = (p1.x - p2.x - p2.width) <= attackRange;
                    } else if (!p1.facingLeft && p2.x > p1.x) {
                        // Attaque vers la droite  
                        canHit = (p2.x - p1.x - p1.width) <= attackRange;
                    }
                    
                    if (canHit) {
                        let damage = calculateComboDamage(p1);
                        let knockback = calculateComboKnockback(p1);
                        
                        // Bonus de d√©g√¢ts pour contre-attaque
                        if (p1.isCounterAttacking) {
                            damage = Math.floor(damage * 1.5); // 50% de bonus
                            knockback = Math.floor(knockback * 1.3);
                            console.log(`üí• CONTRE-ATTAQUE ! D√©g√¢ts: ${damage} (+50%)`);
                        }
                        
                        // Bonus pour attaque a√©rienne
                        if (p1.isAirAttacking) {
                            damage = Math.floor(damage * 1.2); // 20% de bonus
                            console.log(`‚úàÔ∏è ATTAQUE A√âRIENNE ! D√©g√¢ts: ${damage} (+20%)`);
                        }
                        
                        // Calcul du point d'impact pr√©cis (style Tekken)
                        const impactX = p2.x + p2.width/2; // Centre du receveur
                        const impactY = p2.y + p2.height/3; // Partie haute du corps
                        
                        // Appliquer les effets sp√©ciaux AVANT takeDamage pour √©viter animation double
                        if (p1.comboType === 'low') {
                            // Low attack met l'adversaire au sol !
                            p2.isDown = true;
                            p2.downTimer = p2.downDuration;
                            p2.vy = 0; // Pas de projection verticale
                            p2.vx = (p2.x > p1.x ? 100 : -100); // R√©duit de 200 √† 100 pour knockdown
                            console.log(`üî• ${p2.type}: KNOCKED DOWN! Timer=${p2.downTimer} - isDown=${p2.isDown}`);
                            // Effet d'impact knockdown sur les jambes/bas du corps
                            const lowImpactY = p2.y + (p2.height * 2/3);
                            impactEffects.push(new ImpactEffect(impactX, lowImpactY, 'knockdown', 800));
                            // Screen shake intense pour knockdown
                            screenShake = { x: 0, y: 0, intensity: 12, duration: 500 };
                        }
                        
                        // Appliquer les d√©g√¢ts APR√àS les effets sp√©ciaux
                        const damageResult = p2.takeDamage(damage, p1.x, p1.comboType, p1);
                        
                        // R√©actions selon le r√©sultat de l'attaque
                        if (damageResult === "perfect_parry") {
                            // Perfect parry r√©ussi - l'attaquant est stunn√©
                            p1.blockStun = 30;
                            p1.isCounterAttacking = false;
                            console.log(`üõ°Ô∏è ${p2.type} : Perfect Parry sur ${p1.type}!`);
                            screenShake = { x: 0, y: 0, intensity: 4, duration: 200 };
                            return; // Pas de d√©g√¢ts
                        } else if (damageResult === "perfect_dodge") {
                            // Perfect dodge - aucun effet
                            console.log(`üí® ${p2.type} : Perfect Dodge!`);
                            return;
                        } else if (damageResult === "guard_break") {
                            // Garde cass√©e - effet sp√©cial
                            impactEffects.push(new ImpactEffect(impactX, impactY, 'guard_break', 600));
                            screenShake = { x: 0, y: 0, intensity: 10, duration: 400 };
                        } else if (damageResult === "blocked") {
                            // Attaque bloqu√©e normalement
                            impactEffects.push(new ImpactEffect(impactX, impactY, 'block', 300));
                            screenShake = { x: 0, y: 0, intensity: 3, duration: 150 };
                            // Pas de knockback sur block
                            return;
                        }
                        
                        // Attaque r√©ussie (hit, counter, etc.)
                        if (damageResult === "hit" || damageResult === "guard_break") {
                            p1.hasHit = true;
                            p1.isCounterAttacking = false; // Reset counter apr√®s usage
                            
                            // Gestion sp√©ciale des attaques a√©riennes
                            if (p1.isAirAttacking) {
                                // Air attack spike - envoie vers le bas
                                p2.vy = 300; // Force vers le bas
                                p2.vx = (p2.x > p1.x ? knockback * 0.8 : -knockback * 0.8);
                                p1.airComboCount++;
                                impactEffects.push(new ImpactEffect(impactX, impactY, 'air_spike', 400));
                                console.log(`‚úàÔ∏è Air Attack! Combo: ${p1.airComboCount}`);
                            } else {
                                // Effets selon le type de combo terrestre
                                if (p1.comboType === 'uppercut') {
                                    p2.vy = -400; // Projette vers le haut
                                    p2.vx = (p2.x > p1.x ? 120 : -120);
                                    impactEffects.push(new ImpactEffect(impactX, impactY, 'critical', 500));
                                    screenShake = { x: 0, y: 0, intensity: 8, duration: 300 };
                                } else if (p1.comboType === 'double') {
                                    p2.vx = (p2.x > p1.x ? knockback * 1.2 : -knockback * 1.2);
                                    impactEffects.push(new ImpactEffect(impactX - 10, impactY, 'critical', 400));
                                    setTimeout(() => {
                                        impactEffects.push(new ImpactEffect(impactX + 10, impactY + 15, 'critical', 400));
                                    }, 150);
                                    screenShake = { x: 0, y: 0, intensity: 6, duration: 200 };
                                    setTimeout(() => {
                                        screenShake = { x: 0, y: 0, intensity: 8, duration: 300 };
                                    }, 150);
                                } else if (p1.comboType !== 'low') { // Low attack d√©j√† g√©r√©
                                    p2.vx = (p2.x > p1.x ? knockback : -knockback);
                                    impactEffects.push(new ImpactEffect(impactX, impactY + 10, 'hit', 350));
                                    screenShake = { x: 0, y: 0, intensity: 4, duration: 150 };
                                }
                            }
                            
                            // V√©rifier wall bounce apr√®s knockback
                            checkWallBounce(p2);
                            
                        } else {
                            // Effet de garde r√©ussie (ne devrait plus arriver avec la nouvelle logique)
                            impactEffects.push(new ImpactEffect(impactX, impactY, 'blocked', 300));
                            screenShake = { x: 0, y: 0, intensity: 3, duration: 150 };
                        }
                        
                        // Affichage du type d'attaque
                        showComboNotification(p1);
                    }
                }
                if (p2.isAttacking && !p2.hasHit && p2.animationFrame >= 2) {
                    // V√©rifier que p2 attaque dans la bonne direction ET √† bonne port√©e
                    const attackRange = p2.isAirAttacking ? 70 : 50; // Plus de port√©e en l'air
                    let canHit = false;
                    
                    if (p2.facingLeft && p1.x < p2.x) {
                        // Attaque vers la gauche
                        canHit = (p2.x - p1.x - p1.width) <= attackRange;
                    } else if (!p2.facingLeft && p1.x > p2.x) {
                        // Attaque vers la droite
                        canHit = (p1.x - p2.x - p2.width) <= attackRange;
                    }
                    
                    if (canHit) {
                        let damage = calculateComboDamage(p2);
                        let knockback = calculateComboKnockback(p2);
                        
                        // Bonus de d√©g√¢ts pour contre-attaque
                        if (p2.isCounterAttacking) {
                            damage = Math.floor(damage * 1.5); // 50% de bonus
                            knockback = Math.floor(knockback * 1.3);
                            console.log(`üí• CONTRE-ATTAQUE ! D√©g√¢ts: ${damage} (+50%)`);
                        }
                        
                        // Bonus pour attaque a√©rienne
                        if (p2.isAirAttacking) {
                            damage = Math.floor(damage * 1.2); // 20% de bonus
                            console.log(`‚úàÔ∏è ATTAQUE A√âRIENNE ! D√©g√¢ts: ${damage} (+20%)`);
                        }
                        
                        // Calcul du point d'impact pr√©cis (style Tekken)
                        const impactX = p1.x + p1.width/2; // Centre du receveur
                        const impactY = p1.y + p1.height/3; // Partie haute du corps
                        
                        // Appliquer les effets sp√©ciaux AVANT takeDamage pour √©viter animation double
                        if (p2.comboType === 'low') {
                            // Low attack met l'adversaire au sol !
                            p1.isDown = true;
                            p1.downTimer = p1.downDuration;
                            p1.vy = 0; // Pas de projection verticale
                            p1.vx = (p1.x > p2.x ? 100 : -100); // R√©duit de 200 √† 100 pour knockdown
                            console.log(`${p1.type}: KNOCKED DOWN!`);
                            // Effet d'impact knockdown sur les jambes/bas du corps
                            const lowImpactY = p1.y + (p1.height * 2/3);
                            impactEffects.push(new ImpactEffect(impactX, lowImpactY, 'knockdown', 800));
                            // Screen shake intense pour knockdown
                            screenShake = { x: 0, y: 0, intensity: 12, duration: 500 };
                        }
                        
                        // Appliquer les d√©g√¢ts APR√àS les effets sp√©ciaux
                        const damageResult = p1.takeDamage(damage, p2.x, p2.comboType, p2);
                        
                        // R√©actions selon le r√©sultat de l'attaque
                        if (damageResult === "perfect_parry") {
                            // Perfect parry r√©ussi - l'attaquant est stunn√©
                            p2.blockStun = 30;
                            p2.isCounterAttacking = false;
                            console.log(`üõ°Ô∏è ${p1.type} : Perfect Parry sur ${p2.type}!`);
                            screenShake = { x: 0, y: 0, intensity: 4, duration: 200 };
                            return; // Pas de d√©g√¢ts
                        } else if (damageResult === "perfect_dodge") {
                            // Perfect dodge - aucun effet
                            console.log(`üí® ${p1.type} : Perfect Dodge!`);
                            return;
                        } else if (damageResult === "guard_break") {
                            // Garde cass√©e - effet sp√©cial
                            impactEffects.push(new ImpactEffect(impactX, impactY, 'guard_break', 600));
                            screenShake = { x: 0, y: 0, intensity: 10, duration: 400 };
                        } else if (damageResult === "blocked") {
                            // Attaque bloqu√©e normalement
                            impactEffects.push(new ImpactEffect(impactX, impactY, 'block', 300));
                            screenShake = { x: 0, y: 0, intensity: 3, duration: 150 };
                            // Pas de knockback sur block
                            return;
                        }
                        
                        // Attaque r√©ussie (hit, counter, etc.)
                        if (damageResult === "hit" || damageResult === "guard_break") {
                            p2.hasHit = true;
                            p2.isCounterAttacking = false; // Reset counter apr√®s usage
                            
                            // Gestion sp√©ciale des attaques a√©riennes
                            if (p2.isAirAttacking) {
                                // Air attack spike - envoie vers le bas
                                p1.vy = 300; // Force vers le bas
                                p1.vx = (p1.x > p2.x ? knockback * 0.8 : -knockback * 0.8);
                                p2.airComboCount++;
                                impactEffects.push(new ImpactEffect(impactX, impactY, 'air_spike', 400));
                                console.log(`‚úàÔ∏è Air Attack! Combo: ${p2.airComboCount}`);
                            } else {
                                // Effets selon le type de combo terrestre
                                if (p2.comboType === 'uppercut') {
                                    p1.vy = -400; // Projette vers le haut
                                    p1.vx = (p1.x > p2.x ? 120 : -120);
                                    impactEffects.push(new ImpactEffect(impactX, impactY, 'critical', 500));
                                    screenShake = { x: 0, y: 0, intensity: 8, duration: 300 };
                                } else if (p2.comboType === 'double') {
                                    p1.vx = (p1.x > p2.x ? knockback * 1.2 : -knockback * 1.2);
                                    impactEffects.push(new ImpactEffect(impactX - 10, impactY, 'critical', 400));
                                    setTimeout(() => {
                                        impactEffects.push(new ImpactEffect(impactX + 10, impactY + 15, 'critical', 400));
                                    }, 150);
                                    screenShake = { x: 0, y: 0, intensity: 6, duration: 200 };
                                    setTimeout(() => {
                                        screenShake = { x: 0, y: 0, intensity: 8, duration: 300 };
                                    }, 150);
                                } else if (p2.comboType !== 'low') { // Low attack d√©j√† g√©r√©
                                    p1.vx = (p1.x > p2.x ? knockback : -knockback);
                                    impactEffects.push(new ImpactEffect(impactX, impactY + 10, 'hit', 350));
                                    screenShake = { x: 0, y: 0, intensity: 4, duration: 150 };
                                }
                            }
                            
                            // V√©rifier wall bounce apr√®s knockback
                            checkWallBounce(p1);
                            
                        } else {
                            // Effet de garde r√©ussie (ne devrait plus arriver avec la nouvelle logique)
                            impactEffects.push(new ImpactEffect(impactX, impactY, 'blocked', 300));
                            screenShake = { x: 0, y: 0, intensity: 3, duration: 150 };
                        }
                        
                        // Affichage du type d'attaque
                        showComboNotification(p2);
                    }
                }
            }
            
            document.getElementById('p1Health').textContent = Math.round(p1.health);
            document.getElementById('p2Health').textContent = Math.round(p2.health);
            document.getElementById('p1Stamina').textContent = Math.round(p1.stamina);
            document.getElementById('p2Stamina').textContent = Math.round(p2.stamina);
        }

        // Fonctions utilitaires pour les combos
        function calculateComboDamage(player) {
            switch(player.comboType) {
                case 'double': return player.isDoubleAttack ? 35 : 25; // Double frappe fait plus de d√©g√¢ts
                case 'uppercut': return 30; // Uppercut puissant
                case 'low': return 15; // Attaque basse rapide mais faible
                default: return 20; // Attaque normale
            }
        }

        function calculateComboKnockback(player) {
            switch(player.comboType) {
                case 'double': return 400; // Double frappe projette fort
                case 'uppercut': return 250; // Uppercut moyenne projection horizontale
                case 'low': return 450; // Attaque basse fait glisser
                default: return 300; // Attaque normale
            }
        }

        function showComboNotification(player) {
            // Notification temporaire (√† am√©liorer visuellement plus tard)
            const comboNames = {
                'double': 'DOUBLE HIT!',
                'uppercut': 'UPPERCUT!',
                'low': 'LOW ATTACK!',
                'normal': 'HIT!'
            };
            
            console.log(`${player.type}: ${comboNames[player.comboType] || 'HIT!'}`);
            
            // TODO: Ajouter affichage visuel dans le jeu
        }

        // ü•ä SYST√àME DE ROUNDS PROFESSIONNEL
        function updateRoundSystem(deltaTime) {
            if (!roundSystem.roundInProgress) {
                // Round termin√©, affichage du r√©sultat avec animations
                if (roundSystem.showingRoundResult) {
                    roundSystem.resultTimer += deltaTime;
                    
                    // üé≠ Gestion du temps des animations de victoire/d√©faite
                    if (roundSystem.showingVictoryPoses) {
                        roundSystem.victoryAnimationTime += deltaTime;
                        
                        // Apr√®s la dur√©e des animations, les arr√™ter
                        if (roundSystem.victoryAnimationTime >= roundSystem.victoryAnimationDuration) {
                            console.log('üé≠ Fin des animations de victoire/d√©faite');
                            roundSystem.showingVictoryPoses = false;
                            
                            // Arr√™ter les animations des joueurs
                            if (players[0]) players[0].stopVictoryDefeatPoses();
                            if (players[1]) players[1].stopVictoryDefeatPoses();
                        }
                    }
                    
                    if (roundSystem.resultTimer >= roundSystem.resultDuration) {
                        // Passer au round suivant ou finir le match
                        if (roundSystem.matchFinished) {
                            // Match termin√©, afficher l'√©cran final
                            return;
                        } else {
                            startNextRound();
                        }
                    }
                }
                return;
            }

            // V√©rifier les conditions de fin de round
            const p1 = players[0];
            const p2 = players[1];
            
            if (!p1 || !p2) return;

            // V√©rifier si un joueur est mort
            if (p1.health <= 0) {
                endRound('player2');
            } else if (p2.health <= 0) {
                endRound('player1');
            }

            // V√©rifier le timeout du round (optionnel)
            const elapsedTime = Date.now() - roundSystem.roundStartTime;
            if (elapsedTime >= roundSystem.roundDuration) {
                // D√©terminer le gagnant par la sant√© restante
                if (p1.health > p2.health) {
                    endRound('player1');
                } else if (p2.health > p1.health) {
                    endRound('player2');
                } else {
                    endRound('draw'); // Match nul
                }
            }
        }

        function endRound(winner) {
            roundSystem.roundInProgress = false;
            roundSystem.showingRoundResult = true;
            roundSystem.showingVictoryPoses = true; // üé≠ Activer les animations
            roundSystem.victoryAnimationTime = 0;
            roundSystem.resultTimer = 0;

            // Comptabiliser la victoire et d√©clencher les animations appropri√©es
            if (winner === 'player1') {
                roundSystem.p1Wins++;
                roundSystem.roundWinner = players[0];
                roundSystem.roundLoser = players[1];
                console.log(`ü•ä ROUND ${roundSystem.currentRound}: JOUEUR 1 GAGNE!`);
                
                // üéâ D√©clencher les animations de victoire/d√©faite
                if (players[0]) players[0].startVictoryPose();
                if (players[1]) players[1].startDefeatPose();
                
            } else if (winner === 'player2') {
                roundSystem.p2Wins++;
                roundSystem.roundWinner = players[1];
                roundSystem.roundLoser = players[0];
                console.log(`ü•ä ROUND ${roundSystem.currentRound}: JOUEUR 2 GAGNE!`);
                
                // üéâ D√©clencher les animations de victoire/d√©faite
                if (players[1]) players[1].startVictoryPose();
                if (players[0]) players[0].startDefeatPose();
                
            } else {
                console.log(`ü•ä ROUND ${roundSystem.currentRound}: MATCH NUL!`);
                roundSystem.roundWinner = null;
                roundSystem.roundLoser = null;
                // En cas de match nul, pas d'animations sp√©ciales
                roundSystem.showingVictoryPoses = false;
            }

            // V√©rifier si quelqu'un a gagn√© le match (premier √† 3 victoires)
            if (roundSystem.p1Wins >= 3) {
                roundSystem.matchFinished = true;
                roundSystem.winner = 'player1';
                console.log(`üèÜ JOUEUR 1 REMPORTE LE MATCH! (${roundSystem.p1Wins}-${roundSystem.p2Wins})`);
            } else if (roundSystem.p2Wins >= 3) {
                roundSystem.matchFinished = true;
                roundSystem.winner = 'player2';
                console.log(`üèÜ JOUEUR 2 REMPORTE LE MATCH! (${roundSystem.p2Wins}-${roundSystem.p1Wins})`);
            }

            // Arr√™ter les animations et effets de combat (mais pas les victoire/d√©faite)
            if (players[0] && !players[0].isInVictoryPose && !players[0].isInDefeatPose) {
                players[0].isAttacking = false;
                players[0].isGatling = false;
                players[0].isCombo = false;
                players[0].isBlocking = false;
            }
            if (players[1] && !players[1].isInVictoryPose && !players[1].isInDefeatPose) {
                players[1].isAttacking = false;
                players[1].isGatling = false;
                players[1].isCombo = false;
                players[1].isBlocking = false;
            }
        }

        function startNextRound() {
            roundSystem.currentRound++;
            roundSystem.roundInProgress = true;
            roundSystem.showingRoundResult = false;
            roundSystem.roundStartTime = Date.now();

            console.log(`ü•ä D√âBUT DU ROUND ${roundSystem.currentRound}`);
            console.log(`üìä Score: Joueur 1 = ${roundSystem.p1Wins} | Joueur 2 = ${roundSystem.p2Wins}`);

            // R√©initialiser les joueurs pour le nouveau round
            resetPlayersForNewRound();
        }

        function resetPlayersForNewRound() {
            if (players[0]) {
                players[0].health = players[0].maxHealth;
                players[0].stamina = players[0].maxStamina;
                players[0].x = 200;
                players[0].y = 620;
                players[0].vx = 0;
                players[0].vy = 0;
                players[0].animationState = 'idle';
                players[0].animationFrame = 1;
                players[0].isAttacking = false;
                players[0].isGatling = false;
                players[0].isCombo = false;
                players[0].isBlocking = false;
                players[0].isHurt = false;
                players[0].isDown = false;
                players[0].facingLeft = false;
                // üé≠ Arr√™ter les animations de victoire/d√©faite
                players[0].stopVictoryDefeatPoses();
            }

            if (players[1]) {
                players[1].health = players[1].maxHealth;
                players[1].stamina = players[1].maxStamina;
                players[1].x = 1000;
                players[1].y = 620;
                players[1].vx = 0;
                players[1].vy = 0;
                players[1].animationState = 'idle';
                players[1].animationFrame = 1;
                players[1].isAttacking = false;
                players[1].isGatling = false;
                players[1].isCombo = false;
                players[1].isBlocking = false;
                players[1].isHurt = false;
                players[1].isDown = false;
                players[1].facingLeft = true;
                // üé≠ Arr√™ter les animations de victoire/d√©faite
                players[1].stopVictoryDefeatPoses();
            }

            // Vider les effets et projectiles
            impactEffects.length = 0;
            projectiles.length = 0;
        }

        function resetMatch() {
            roundSystem.currentRound = 1;
            roundSystem.p1Wins = 0;
            roundSystem.p2Wins = 0;
            roundSystem.roundInProgress = true;
            roundSystem.showingRoundResult = false;
            roundSystem.matchFinished = false;
            roundSystem.winner = null;
            roundSystem.roundStartTime = Date.now();
            // üé≠ R√©initialiser les variables d'animation
            roundSystem.showingVictoryPoses = false;
            roundSystem.victoryAnimationTime = 0;
            roundSystem.roundWinner = null;
            roundSystem.roundLoser = null;
            
            resetPlayersForNewRound();
            console.log(`üîÑ NOUVEAU MATCH COMMENC√â!`);
        }

        function renderTraditionalDojo(ctx) {
            // ARRI√àRE-PLAN D√âGRAD√â SOPHISTIQU√â
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#1a0f0a'); // Nuit profonde
            skyGradient.addColorStop(0.2, '#2d1b12'); // Brun sombre
            skyGradient.addColorStop(0.6, '#4a2c1a'); // Brun chaud
            skyGradient.addColorStop(0.85, '#3d2817'); // Transition
            skyGradient.addColorStop(1, '#2a1810'); // Base sombre
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // EFFET DE BROUILLARD/FUM√âE EN ARRI√àRE-PLAN
            for (let i = 0; i < 8; i++) {
                const fogGradient = ctx.createRadialGradient(
                    100 + i * 150 + Math.sin(time + i) * 50, 
                    300 + Math.cos(time * 0.5 + i) * 30, 
                    0,
                    100 + i * 150 + Math.sin(time + i) * 50, 
                    300 + Math.cos(time * 0.5 + i) * 30, 
                    120
                );
                fogGradient.addColorStop(0, 'rgba(60, 40, 25, 0.1)');
                fogGradient.addColorStop(1, 'rgba(60, 40, 25, 0)');
                ctx.fillStyle = fogGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // MURS AVEC TEXTURE BOIS R√âALISTE
            function drawWoodTexture(x, y, width, height, vertical = true) {
                // Base wood color
                const woodGradient = ctx.createLinearGradient(x, y, x + (vertical ? 0 : width), y + (vertical ? height : 0));
                woodGradient.addColorStop(0, '#8B4513');
                woodGradient.addColorStop(0.2, '#A0522D');
                woodGradient.addColorStop(0.4, '#8B4513');
                woodGradient.addColorStop(0.6, '#654321');
                woodGradient.addColorStop(0.8, '#8B4513');
                woodGradient.addColorStop(1, '#5D4037');
                ctx.fillStyle = woodGradient;
                ctx.fillRect(x, y, width, height);
                
                // Veines du bois
                ctx.strokeStyle = 'rgba(101, 67, 33, 0.6)';
                ctx.lineWidth = 1;
                for (let i = 0; i < (vertical ? height : width); i += 15) {
                    ctx.beginPath();
                    if (vertical) {
                        ctx.moveTo(x, y + i);
                        ctx.quadraticCurveTo(x + width/2 + Math.sin(i * 0.1) * 3, y + i + 7, x + width, y + i);
                    } else {
                        ctx.moveTo(x + i, y);
                        ctx.quadraticCurveTo(x + i + 7, y + height/2 + Math.sin(i * 0.1) * 3, x + i, y + height);
                    }
                    ctx.stroke();
                }
            }
            
            // COLONNES PRINCIPALES AVEC RELIEF ET OMBRES
            // Colonne gauche
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 8;
            ctx.shadowOffsetY = 5;
            drawWoodTexture(45, 80, 45, 620, true);
            
            // D√©tails sculpt√©s sur la colonne
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#654321';
            for (let i = 0; i < 6; i++) {
                ctx.fillRect(48, 120 + i * 80, 39, 3);
                ctx.fillRect(55, 110 + i * 80, 25, 2);
            }
            
            // Colonne droite
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = -8;
            ctx.shadowOffsetY = 5;
            drawWoodTexture(canvas.width - 90, 80, 45, 620, true);
            
            // D√©tails sculpt√©s sur la colonne droite
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#654321';
            for (let i = 0; i < 6; i++) {
                ctx.fillRect(canvas.width - 87, 120 + i * 80, 39, 3);
                ctx.fillRect(canvas.width - 80, 110 + i * 80, 25, 2);
            }
            
            // POUTRES HORIZONTALES AVEC D√âTAILS ARCHITECTURAUX
            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 5;
            drawWoodTexture(45, 140, canvas.width - 90, 25, false);
            drawWoodTexture(45, 190, canvas.width - 90, 25, false);
            
            // Supports d√©coratifs
            ctx.shadowBlur = 0;
            for (let x = 100; x < canvas.width - 100; x += 80) {
                drawWoodTexture(x - 3, 135, 6, 35, true);
            }
            
            // SOL EN BOIS MARRON √âL√âGANT
            function drawWoodFloor(x, y, width, height) {
                // Base du sol en bois marron
                const floorGradient = ctx.createLinearGradient(x, y, x + width, y + height);
                floorGradient.addColorStop(0, '#8B4513'); // Marron classique
                floorGradient.addColorStop(0.3, '#A0522D'); // Marron saddlebrown
                floorGradient.addColorStop(0.7, '#8B4513'); // Marron moyen
                floorGradient.addColorStop(1, '#654321'); // Marron fonc√©
                ctx.fillStyle = floorGradient;
                ctx.fillRect(x, y, width, height);
                
                // Bordure d√©corative
                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 3;
                ctx.strokeRect(x + 2, y + 2, width - 4, height - 4);
                
                // Texture de bois (planches)
                ctx.strokeStyle = 'rgba(101, 67, 33, 0.6)';
                ctx.lineWidth = 1;
                for (let i = 0; i < width; i += 4) {
                    ctx.beginPath();
                    ctx.moveTo(x + i, y);
                    ctx.lineTo(x + i, y + height);
                    ctx.stroke();
                }
                
                // Joints de planches horizontaux
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                for (let j = 0; j < height; j += 35) {
                    ctx.beginPath();
                    ctx.moveTo(x + 8, y + j);
                    ctx.lineTo(x + width - 8, y + j);
                    ctx.stroke();
                }
                
                // Reflets sur le bois poli
                ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
                ctx.fillRect(x, y, width, 3);
            }
            
            // Sol principal en bois marron
            const floorW = 160;
            const floorH = 80;
            for (let x = 0; x < canvas.width; x += floorW) {
                for (let y = 680; y < canvas.height; y += floorH) {
                    drawWoodFloor(x, y, floorW, floorH);
                }
            }
            
            // PLATEFORMES EN BOIS NOBLE AVEC RELIEF
            function drawPlatform(x, y, width, height) {
                // Ombre de la plateforme
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(x + 3, y + 3, width, height);
                
                // Base de la plateforme
                const platformGradient = ctx.createLinearGradient(x, y, x, y + height);
                platformGradient.addColorStop(0, '#D2691E');
                platformGradient.addColorStop(0.5, '#CD853F');
                platformGradient.addColorStop(1, '#A0522D');
                ctx.fillStyle = platformGradient;
                ctx.fillRect(x, y, width, height);
                
                // Planches individuelles avec joints
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 1;
                for (let i = 0; i < width; i += 28) {
                    ctx.beginPath();
                    ctx.moveTo(x + i, y);
                    ctx.lineTo(x + i, y + height);
                    ctx.stroke();
                }
                
                // Reflets sur le bois
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(x, y, width, 2);
            }
            
            // Plateformes accessibles avec des hauteurs r√©alistes pour le saut
            drawPlatform(280, 600, 220, 20); // Plateforme gauche - plus basse et plus large
            drawPlatform(680, 480, 220, 20); // Plateforme droite - hauteur accessible
            drawPlatform(480, 380, 220, 20); // Plateforme centrale - progression logique
            
            // LANTERNES JAPONAISES D√âTAILL√âES AVEC LUEUR DYNAMIQUE (SANS BONUS TACTIQUES)
            function drawLantern(x, y, symbol) {
                const glowIntensity = 0.7 + 0.3 * Math.sin(time * 2);
                
                // Lueur externe anim√©e (purement d√©corative)
                const outerGlow = ctx.createRadialGradient(x, y + 25, 0, x, y + 25, 100);
                outerGlow.addColorStop(0, `rgba(255, 180, 100, ${glowIntensity * 0.4})`);
                outerGlow.addColorStop(0.5, `rgba(255, 200, 120, ${glowIntensity * 0.2})`);
                outerGlow.addColorStop(1, 'rgba(255, 220, 150, 0)');
                ctx.fillStyle = outerGlow;
                ctx.fillRect(x - 80, y - 50, 160, 150);
                
                // Structure de la lanterne
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 25, y, 50, 60);
                
                // Papier lumineux avec gradient chaud
                const paperGradient = ctx.createRadialGradient(x, y + 30, 0, x, y + 30, 20);
                paperGradient.addColorStop(0, `rgba(255, 220, 180, ${glowIntensity})`);
                paperGradient.addColorStop(0.7, `rgba(255, 200, 150, ${glowIntensity * 0.8})`);
                paperGradient.addColorStop(1, `rgba(255, 180, 120, ${glowIntensity * 0.6})`);
                ctx.fillStyle = paperGradient;
                ctx.fillRect(x - 20, y + 5, 40, 50);
                
                // D√©tails m√©talliques
                ctx.fillStyle = '#654321';
                ctx.fillRect(x - 25, y, 50, 3);
                ctx.fillRect(x - 25, y + 57, 50, 3);
                ctx.fillRect(x - 2, y, 4, 60);
                
                // Symbole avec effet lumineux
                ctx.fillStyle = '#8B0000';
                ctx.font = 'bold 18px serif';
                ctx.textAlign = 'center';
                ctx.fillText(symbol, x, y + 35);
                
                // Corde
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x, y - 30);
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            
            drawLantern(200, 170, 'Ê≠¶');
            drawLantern(canvas.width - 200, 170, 'ÈÅì');
            
            // PANNEAUX D√âCORATIFS SCULPT√âS
            function drawPanel(x, y, symbol) {
                // Ombre du panneau
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fillRect(x + 3, y + 3, 90, 80);
                
                // Cadre du panneau
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x, y, 90, 80);
                
                // Surface sculpt√©e
                const panelGradient = ctx.createLinearGradient(x, y, x + 90, y + 80);
                panelGradient.addColorStop(0, '#D2691E');
                panelGradient.addColorStop(0.5, '#CD853F');
                panelGradient.addColorStop(1, '#A0522D');
                ctx.fillStyle = panelGradient;
                ctx.fillRect(x + 8, y + 8, 74, 64);
                
                // Motifs d√©coratifs
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(x + 12, y + 12, 66, 56);
                
                // Symbole central avec relief
                ctx.fillStyle = '#2C1810';
                ctx.font = 'bold 24px serif';
                ctx.textAlign = 'center';
                ctx.fillText(symbol, x + 45, y + 50);
                
                // Highlight pour l'effet 3D
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(x, y, 90, 2);
                ctx.fillRect(x, y, 2, 80);
            }
            
            drawPanel(110, 240, 'Âøç');
            drawPanel(canvas.width - 200, 240, 'ËÄÖ');
            
            // EFFETS DE PARTICULES FLOTTANTES (poussi√®re/cendre)
            for (let i = 0; i < 15; i++) {
                const particleX = (i * 67 + time * 20) % canvas.width;
                const particleY = 100 + i * 40 + Math.sin(time + i) * 30;
                const size = 1 + Math.sin(time * 2 + i) * 0.5;
                
                ctx.fillStyle = `rgba(200, 180, 160, ${0.3 + Math.sin(time + i) * 0.2})`;
                ctx.beginPath();
                ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Reflets et ombres douces sur le sol
            const reflectionGradient = ctx.createLinearGradient(0, 680, 0, 680 + 30);
            reflectionGradient.addColorStop(0, 'rgba(255, 248, 220, 0.08)');
            reflectionGradient.addColorStop(1, 'rgba(255, 248, 220, 0)');
            ctx.fillStyle = reflectionGradient;
            ctx.fillRect(0, 680, canvas.width, 30);
            
            // Ombres port√©es des colonnes
            const shadowGradient = ctx.createLinearGradient(80, 680, 120, 680);
            shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.15)');
            shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = shadowGradient;
            ctx.fillRect(80, 680, 40, canvas.height - 680);
            
            const shadowGradient2 = ctx.createLinearGradient(canvas.width - 120, 680, canvas.width - 80, 680);
            shadowGradient2.addColorStop(0, 'rgba(0, 0, 0, 0)');
            shadowGradient2.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
            ctx.fillStyle = shadowGradient2;
            ctx.fillRect(canvas.width - 120, 680, 40, canvas.height - 680);
            
            // RESET SHADOW POUR NE PAS AFFECTER LE RESTE
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        // ü•ä AFFICHAGE DU SYST√àME DE ROUNDS
        function renderRoundSystem(ctx) {
            // AFFICHAGE PERMANENT DU SCORE ET ROUND
            ctx.save();
            
            // Panneau de score en haut au centre
            const panelWidth = 300;
            const panelHeight = 80;
            const panelX = (canvas.width - panelWidth) / 2;
            const panelY = 10;
            
            // Fond du panneau avec gradient
            const panelGradient = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelHeight);
            panelGradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
            panelGradient.addColorStop(1, 'rgba(50, 30, 20, 0.9)');
            ctx.fillStyle = panelGradient;
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
            
            // Bordure dor√©e
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
            
            // Titre du round
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`ROUND ${roundSystem.currentRound}`, panelX + panelWidth/2, panelY + 25);
            
            // Score des joueurs
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#FFFFFF';
            
            // Joueur 1 (gauche)
            ctx.textAlign = 'left';
            ctx.fillText(`JOUEUR 1`, panelX + 20, panelY + 50);
            ctx.fillStyle = roundSystem.p1Wins >= 3 ? '#00FF00' : '#FFD700';
            ctx.fillText(`${roundSystem.p1Wins} Victoires`, panelX + 20, panelY + 70);
            
            // Joueur 2 (droite)
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'right';
            ctx.fillText(`JOUEUR 2${aiEnabled ? ' ü§ñ' : ''}`, panelX + panelWidth - 20, panelY + 50);
            if (aiEnabled) {
                ctx.fillStyle = '#00FFFF';
                ctx.font = '12px Arial';
                ctx.fillText(`IA ACTIVE`, panelX + panelWidth - 20, panelY + 35);
                ctx.font = '16px Arial';
            }
            ctx.fillStyle = roundSystem.p2Wins >= 3 ? '#00FF00' : '#FFD700';
            ctx.fillText(`${roundSystem.p2Wins} Victoires`, panelX + panelWidth - 20, panelY + 70);
            
            // √âCRAN DE R√âSULTAT DE ROUND
            if (roundSystem.showingRoundResult) {
                // Overlay semi-transparent
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (roundSystem.matchFinished) {
                    // MATCH TERMIN√â
                    ctx.save();
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 48px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    
                    const winnerText = roundSystem.winner === 'player1' ? 'JOUEUR 1 GAGNE!' : 'JOUEUR 2 GAGNE!';
                    ctx.strokeText(winnerText, canvas.width/2, canvas.height/2 - 50);
                    ctx.fillText(winnerText, canvas.width/2, canvas.height/2 - 50);
                    
                    ctx.font = 'bold 24px Arial';
                    ctx.fillStyle = '#FFFFFF';
                    const scoreText = `Score Final: ${roundSystem.p1Wins} - ${roundSystem.p2Wins}`;
                    ctx.strokeText(scoreText, canvas.width/2, canvas.height/2);
                    ctx.fillText(scoreText, canvas.width/2, canvas.height/2);
                    
                    ctx.font = 'bold 18px Arial';
                    ctx.fillStyle = '#FFD700';
                    ctx.strokeText('Appuyez sur R pour un nouveau match', canvas.width/2, canvas.height/2 + 50);
                    ctx.fillText('Appuyez sur R pour un nouveau match', canvas.width/2, canvas.height/2 + 50);
                    ctx.restore();
                    
                } else {
                    // TRANSITION DE ROUND - Affichage minimaliste
                    // Laisser d'abord les animations se jouer sans texte intrusif
                    
                    // Seulement afficher l'annonce du prochain round dans les derni√®res secondes
                    const timeLeft = Math.ceil((roundSystem.resultDuration - roundSystem.resultTimer) / 1000);
                    if (timeLeft <= 2) {
                        ctx.save();
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 28px Arial';
                        ctx.textAlign = 'center';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        
                        const roundText = `ROUND ${roundSystem.currentRound + 1}`;
                        ctx.strokeText(roundText, canvas.width/2, canvas.height/2);
                        ctx.fillText(roundText, canvas.width/2, canvas.height/2);
                        ctx.restore();
                    }
                }
            }
            
            ctx.restore();
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ÔøΩ RENDU SELON L'√âTAT DU JEU
            if (gameState === 'characterSelect') {
                renderCharacterSelect();
                return;
            }
            
            // ÔøΩüé¨ APPLIQUER LES TRANSFORMATIONS DE CAM√âRA DYNAMIQUE
            ctx.save();
            
            // Calculer le centre de la cam√©ra (suivre le joueur en attaque sp√©ciale)
            let centerX = canvas.width / 2 + camera.x;
            let centerY = canvas.height / 2 + camera.y;
            
            // Appliquer le zoom
            const scale = camera.scale;
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(-centerX, -centerY);
            
            // Appliquer le screen shake (ancien syst√®me + nouveau)
            let shakeX = camera.shakeX;
            let shakeY = camera.shakeY;
            
            if (screenShake.duration > 0) {
                shakeX += screenShake.x;
                shakeY += screenShake.y;
            }
            
            ctx.translate(shakeX, shakeY);
            
            // Effet visual du slow motion
            if (timeScale < 1.0) {
                ctx.save();
                ctx.fillStyle = 'rgba(255, 215, 0, 0.1)'; // Teinte dor√©e pour l'effet sp√©cial
                ctx.fillRect(-shakeX - centerX, -shakeY - centerY, canvas.width * 2, canvas.height * 2);
                ctx.restore();
            }
            
            // Dojo traditionnel japonais magnifique (sans effets tactiques)
            renderTraditionalDojo(ctx);
            
            for (const projectile of projectiles) {
                projectile.render(ctx);
            }
            
            for (const player of players) {
                player.render(ctx);
            }
            
            // Rendre les effets d'impact d'abord
            for (const effect of impactEffects) {
                effect.render(ctx);
            }
            
            // üí• RENDU DES PARTICULES STYLE TEKKEN PAR-DESSUS
            particles.forEach(particle => {
                particle.render(ctx);
            });
            
            if (timeScale < 1.0) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 255, 255, 0.9)';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText('‚ö° SLOW MOTION ‚ö°', canvas.width / 2, 100);
                ctx.fillText('‚ö° SLOW MOTION ‚ö°', canvas.width / 2, 100);
                ctx.restore();
            }
            
            // ü•ä AFFICHAGE DU SYST√àME DE ROUNDS
            renderRoundSystem(ctx);
            
            // ü•ä EFFETS DE FREEZE FRAME (flash blanc)
            renderFreezeEffects(ctx);
            
            // INSTRUCTIONS SIMPLES (en bas de l'√©cran)
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('ü•ä Attaque: Z/L | Gatling: O/Numpad3 | Saut: Espace/Fl√®che Haut | R: Nouveau Match', 10, canvas.height - 40);
            ctx.fillText('üèÉ Mouvement: ZQSD / Fl√®ches | Garde: S/Fl√®che Bas', 10, canvas.height - 20);
            ctx.restore();
            
            // Restaurer le contexte du screen shake
            ctx.restore();
        }

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            // üéµ Initialiser l'audio au premier input
            initAudio();
            
            // üéÆ CONTR√îLES √âCRAN DE S√âLECTION
            if (gameState === 'characterSelect') {
                handleCharacterSelectInput(e.code);
                return;
            }
            
            if (e.code === 'KeyC') { // Technique sp√©ciale sur C
                e.preventDefault();
                if (players[0]) players[0].chargeSpecialAttack();
            }

            if (e.shiftKey && e.code === 'KeyL') {
                e.preventDefault();
                if (players[1]) players[1].chargeSpecialAttack();
            }
            
            // ü§ñ Activer/d√©sactiver l'IA avec la touche F1
            if (e.code === 'F1') {
                e.preventDefault();
                aiEnabled = !aiEnabled;
                console.log(`ü§ñ IA ${aiEnabled ? 'ACTIV√âE' : 'D√âSACTIV√âE'} ! (Player 2 = ${aiEnabled ? 'IA' : 'Manuel'})`);
            }

            
            if (e.code === 'KeyR') {
                e.preventDefault();
                if (roundSystem.matchFinished) {
                    resetMatch(); // Nouveau match si le pr√©c√©dent est termin√©
                } else {
                    location.reload(); // Rechargement complet sinon
                }
            } else if (e.code === 'KeyP') {
                gameRunning = !gameRunning;
                if (gameRunning) requestAnimationFrame(gameLoop);
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // ü•ä FONCTIONS √âCRAN DE S√âLECTION DE PERSONNAGES
        
        function updateCharacterSelect(deltaTime) {
            // Animation des sprites idle
            characterSelect.animationTimer += deltaTime;
            if (characterSelect.animationTimer >= 300) { // 300ms par frame
                characterSelect.animationTimer = 0;
                // Les frames idle vont de 1 √† 4, on boucle
            }
        }
        
        function renderCharacterSelect() {
            // ÔøΩ FOND TR√àS SOMBRE - STYLE MODERNE
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0a0a');
            gradient.addColorStop(0.5, '#1a1a1a');
            gradient.addColorStop(1, '#0a0a0a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ‚ú® OVERLAY SUBTIL
            ctx.fillStyle = 'rgba(0, 20, 40, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // üèÜ TITRE STYL√â
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#FF6600';
            ctx.shadowBlur = 10;
            ctx.fillText('SELECT FIGHTER', canvas.width / 2, 100);
            ctx.shadowBlur = 0;
            
            // üéÆ ZONES JOUEURS R√âDUITES ET √âPUR√âES - 2 PERSONNAGES
            renderPlayerSelection(1, 400, 250); // P1 √† gauche
            renderPlayerSelection(2, 800, 250); // P2 √† droite
            
            // ‚öîÔ∏è VS STYL√â AU CENTRE
            ctx.fillStyle = '#FF3333';
            ctx.font = 'bold 72px Arial';
            ctx.shadowColor = '#990000';
            ctx.shadowBlur = 15;
            ctx.fillText('VS', canvas.width / 2, 400);
            ctx.shadowBlur = 0;
            
            // üìã INSTRUCTIONS MINIMALISTES
            ctx.fillStyle = '#888888';
            ctx.font = '20px Arial';
            ctx.fillText('A/D & ‚Üê/‚Üí ‚Ä¢ B & N to confirm ‚Ä¢ ENTER to fight', canvas.width / 2, canvas.height - 40);
        }
        
        function renderPlayerSelection(playerNum, x, y) {
            const selection = playerNum === 1 ? characterSelect.player1Selection : characterSelect.player2Selection;
            const confirmed = playerNum === 1 ? characterSelect.player1Confirmed : characterSelect.player2Confirmed;
            const character = characterSelect.characters[selection];
            
            // üñºÔ∏è CADRE √âL√âGANT ET PLUS GRAND
            const frameSize = 180;
            ctx.strokeStyle = confirmed ? '#00FF88' : (playerNum === 1 ? '#3388FF' : '#FF8833');
            ctx.lineWidth = confirmed ? 6 : 3;
            ctx.strokeRect(x - frameSize/2, y - 30, frameSize, frameSize + 80);
            
            // üåü GLOW EFFECT POUR CONFIRM√â
            if (confirmed) {
                ctx.shadowColor = ctx.strokeStyle;
                ctx.shadowBlur = 20;
                ctx.strokeRect(x - frameSize/2, y - 30, frameSize, frameSize + 80);
                ctx.shadowBlur = 0;
            }
            
            // üë§ SPRITE IDLE ANIM√â - PLUS GRAND !
            const currentFrame = Math.floor(characterSelect.animationTimer / 400) % 4 + 1;
            const characterKey = character.type.toLowerCase().replace(' ', '');
            const spritePath = `assets/characters/${characterKey}/basic/${characterKey}_idle${currentFrame}.png`;
            
            // üîç DEBUG SIMPLE
            if (playerNum === 1 && currentFrame === 1) { // Debug seulement pour P1 frame 1
                console.log(`üéØ Trying: ${spritePath}`);
                console.log(`üéØ Available:`, Object.keys(sprites).filter(k => k.includes('ninja_idle')).slice(0, 3));
            }
            
            // Chercher le sprite sans timestamp
            let sprite = sprites[spritePath];
            
            // üß™ TEST: Si pas trouv√©, essayer un sprite ninja simple
            if (!sprite && characterKey === 'ninja') {
                sprite = sprites['ninja_idle1.png'];
                console.log(`üß™ FALLBACK ninja_idle1.png: ${!!sprite}`);
            }
            
            // üß™ TEST: Si pas trouv√©, essayer un sprite warrior simple
            if (!sprite && characterKey === 'warrior') {
                sprite = sprites['warrior_idle1.png'];
                console.log(`üß™ FALLBACK warrior_idle1.png: ${!!sprite}`);
            }
            
            if (sprite) {
                // Sprite beaucoup plus grand et centr√©
                const spriteSize = 140;
                ctx.drawImage(sprite, x - spriteSize/2, y + 10, spriteSize, spriteSize);
            } else {
                // Fallback rectangle styl√©
                ctx.fillStyle = playerNum === 1 ? '#3388FF' : '#FF8833';
                ctx.fillRect(x - 70, y + 10, 140, 140);
                
                // Texte fallback avec le nom exact cherch√©
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(characterKey, x, y + 75);
                ctx.fillText(`idle${currentFrame}`, x, y + 95);
            }
            
            // üìõ NOM STYL√â
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#000000';
            ctx.shadowBlur = 3;
            ctx.fillText(character.name, x, y + 180);
            ctx.shadowBlur = 0;
            
            // üè∑Ô∏è LABEL JOUEUR DISCRET
            ctx.fillStyle = playerNum === 1 ? '#3388FF' : '#FF8833';
            ctx.font = 'bold 18px Arial';
            ctx.fillText(`P${playerNum}`, x, y - 50);
            
            // ‚úÖ INDICATEUR CONFIRM√â
            if (confirmed) {
                ctx.fillStyle = '#00FF88';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('‚úì READY', x, y + 210);
            }
        }
        
        function handleCharacterSelectInput(keyCode) {
            switch(keyCode) {
                case 'KeyA': // P1 gauche
                    if (!characterSelect.player1Confirmed) {
                        characterSelect.player1Selection = (characterSelect.player1Selection - 1 + characterSelect.characters.length) % characterSelect.characters.length;
                    }
                    break;
                case 'KeyD': // P1 droite
                    if (!characterSelect.player1Confirmed) {
                        characterSelect.player1Selection = (characterSelect.player1Selection + 1) % characterSelect.characters.length;
                    }
                    break;
                case 'KeyB': // P1 confirmer
                    characterSelect.player1Confirmed = !characterSelect.player1Confirmed;
                    break;
                case 'ArrowLeft': // P2 gauche
                    if (!characterSelect.player2Confirmed) {
                        characterSelect.player2Selection = (characterSelect.player2Selection - 1 + characterSelect.characters.length) % characterSelect.characters.length;
                    }
                    break;
                case 'ArrowRight': // P2 droite
                    if (!characterSelect.player2Confirmed) {
                        characterSelect.player2Selection = (characterSelect.player2Selection + 1) % characterSelect.characters.length;
                    }
                    break;
                case 'KeyN': // P2 confirmer
                    characterSelect.player2Confirmed = !characterSelect.player2Confirmed;
                    break;
                case 'Enter': // D√©marrer combat si les deux ont confirm√©
                    if (characterSelect.player1Confirmed && characterSelect.player2Confirmed) {
                        // D√©marrer le combat !
                        startFight();
                    }
                    break;
            }
        }
        
        function startFight() {
            // ü•ä TRANSITION VERS LE COMBAT
            const p1Character = characterSelect.characters[characterSelect.player1Selection];
            const p2Character = characterSelect.characters[characterSelect.player2Selection];
            
            // Cr√©er les joueurs avec les personnages s√©lectionn√©s
            players = [
                new FixedPlayer(200, 620, p1Character.type, true),
                new FixedPlayer(900, 620, p2Character.type, false)
            ];
            
            // Passer en mode combat
            gameState = 'fighting';
            
            // Initialiser le syst√®me de rounds
            roundSystem.roundStartTime = Date.now();
            console.log(`ü•ä COMBAT: ${p1Character.name} vs ${p2Character.name}`);
        }

        // D√©marrer le pr√©chargement
        window.addEventListener('load', preloadSprites);
    </script>
</body>
</html>