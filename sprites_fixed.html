<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jump Ultimate Stars - SPRITES FIXES</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        canvas {
            border: 3px solid #4a90e2;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
        }
        
        #controls, #gameInfo {
            margin: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 1px solid #4a90e2;
        }
        
        #loading {
            color: cyan;
            font-size: 18px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="loading">‚è≥ Chargement des sprites...</div>
        <canvas id="gameCanvas" width="1200" height="800" style="display: none;"></canvas>
        
        <div id="controls" style="display: none;">
            <strong>üéÆ Jump Ultimate Stars - SYST√àME DE COMBOS + DASH & GARDE</strong><br>
            <span style="color: gold;">Joueur 1:</span> WASD + G (attaque) + U (uppercut) + F (attaque basse) + <span style="color: cyan;">Shift+G (Technique Sp√©ciale)</span><br>
            <span style="color: gold;">Nouvelles commandes P1:</span> S (garde) + Q (dash gauche) + E (dash droite)<br>
            <span style="color: lime;">Joueur 2:</span> ‚Üë‚Üì‚Üê‚Üí + L (attaque) + U (uppercut) + F (attaque basse) + <span style="color: cyan;">Shift+L (Technique Sp√©ciale)</span><br>
            <span style="color: lime;">Nouvelles commandes P2:</span> ‚Üì (garde) + 0 (dash gauche) + Entr√©e (dash droite)<br>
            <span style="color: gold;">‚ö° COMBOS: G+G/L+L (double frappe) | U (uppercut) | F (attaque basse)</span><br>
            <span style="color: cyan;">üõ°Ô∏è GARDE: Bloque les attaques frontales (20% d√©g√¢ts) | ‚ö° DASH: Mouvement rapide avec cooldown</span><br>
            R: Red√©marrer | P: Pause
        </div>
        
        <div id="gameInfo" style="display: none;">
            <div>üîã Sant√© P1: <span id="p1Health">100</span>%</div>
            <div>üîã Sant√© P2: <span id="p2Health">100</span>%</div>
            <div>‚ö° Phase: <span id="specialPhase">Normal</span></div>
        </div>
    </div>

    <script>
        // Variables globales
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameRunning = false;
        let keys = {};
        let players = [];
        let projectiles = [];
        let timeScale = 1.0;
        let impactEffects = [];
        
        // Syst√®me de screen shake
        let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
        
        // SYST√àME DE PR√âCHARGEMENT DES SPRITES
        const sprites = {};
        let spritesLoaded = 0;
        let totalSprites = 0;
        
        const spriteList = [
            // Sprites normaux
            'ninja_idle1.png', 'ninja_idle2.png', 'ninja_idle3.png',
            'ninja_walk1.png', 'ninja_walk2.png', 'ninja_walk3.png', 'ninja_walk4.png',
            'ninja_jump1.png', 'ninja_jump2.png',
            'ninja_attack1.png', 'ninja_attack2.png', 'ninja_attack3.png',
            'ninja_hurt1.png', 'ninja_hurt2.png',
            // Nouveaux sprites de combos
            'ninja_uppercut1.png', 'ninja_uppercut2.png', 'ninja_uppercut3.png',
            'ninja_low1.png', 'ninja_low2.png', 'ninja_low3.png',
            'ninja_double1.png', 'ninja_double2.png', 'ninja_double3.png',
            // Sprites de knockdown et relever
            'ninja_down1.png', 'ninja_down2.png', 'ninja_down3.png',
            'ninja_getup1.png', 'ninja_getup2.png', 'ninja_getup3.png', 'ninja_getup4.png',
            // Sprites de dash
            'ninja_dash1.png', 'ninja_dash2.png', 'ninja_dash3.png',
            // Sprites de shield/garde
            'ninja_shield1.png', 'ninja_shield2.png', 'ninja_shield3.png',
            // Sprites sp√©ciaux (fallback vers attack si pas trouv√©)
            'special/ninja_special1.png', 'special/ninja_special2.png', 'special/ninja_special3.png',
            'special/ninja_special4.png', 'special/ninja_special5.png', 'special/ninja_special6.png'
            // Plus besoin de sprite projectile - pure √©nergie maintenant ! ‚ú®
        ];
        
        // Fonction pour obtenir le chemin correct selon la nouvelle organisation
        function getSpritePath(spriteName) {
            const [character, ...actionParts] = spriteName.split('_');
            const fullAction = actionParts.join('_'); // Rejoint au cas o√π il y aurait plusieurs underscores
            
            // Mapping des actions vers les cat√©gories
            const categoryMapping = {
                'idle': 'basic',
                'walk': 'basic', 
                'jump': 'basic',
                'icon': 'basic',
                'attack': 'combat',
                'hurt': 'combat',
                'uppercut': 'special',
                'low': 'special',
                'double': 'special',
                'down': 'special',
                'getup': 'special',
                'dash': 'dash',
                'shield': 'shield'
            };
            
            // Extraire l'action de base (sans le num√©ro)
            let baseAction = 'idle';
            for (const action in categoryMapping) {
                if (fullAction.startsWith(action)) {
                    baseAction = action;
                    break;
                }
            }
            
            const category = categoryMapping[baseAction] || 'basic';
            return `${character}/${category}/${spriteName}`;
        }

        function preloadSprites() {
            totalSprites = spriteList.length;
            document.getElementById('loading').textContent = `‚è≥ Chargement des sprites... (0/${totalSprites})`;
            
            spriteList.forEach(spritePath => {
                const img = new Image();
                const fullPath = spritePath.startsWith('special/') 
                    ? `assets/characters/skills/${spritePath.replace('special/', '')}`
                    : `assets/characters/${getSpritePath(spritePath)}`;
                
                img.onload = () => {
                    sprites[spritePath] = img;
                    spritesLoaded++;
                    console.log(`‚úÖ Sprite charg√©: ${spritePath}`);
                    document.getElementById('loading').textContent = `‚è≥ Chargement des sprites... (${spritesLoaded}/${totalSprites})`;
                    
                    if (spritesLoaded === totalSprites) {
                        startGame();
                    }
                };
                
                img.onerror = () => {
                    console.error(`‚ùå ERREUR: Sprite non trouv√©: ${fullPath}`);
                    // Utiliser une image de fallback ou rectangle
                    sprites[spritePath] = null;
                    spritesLoaded++;
                    document.getElementById('loading').textContent = `‚è≥ Chargement des sprites... (${spritesLoaded}/${totalSprites})`;
                    
                    if (spritesLoaded === totalSprites) {
                        startGame();
                    }
                };
                
                img.src = fullPath;
            });
        }
        
        function startGame() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('gameInfo').style.display = 'block';
            
            console.log(`üéÆ Jeu d√©marr√© avec ${spritesLoaded} sprites charg√©s`);
            gameRunning = true;
            init();
        }
        
        function getSprite(animationState, frame) {
            let spritePath;
            
            // Gestion des nouveaux √©tats de combo
            if (animationState === 'uppercut') {
                spritePath = `ninja_uppercut${frame}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `ninja_attack${Math.min(frame, 3)}.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'low') {
                spritePath = `ninja_low${frame}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `ninja_attack${Math.min(frame, 3)}.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'double') {
                spritePath = `ninja_double${frame}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `ninja_attack${Math.min(frame, 3)}.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'down') {
                // Animation de chute au sol (3 frames)
                spritePath = `ninja_down${Math.min(frame, 3)}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `ninja_hurt${Math.min(frame, 2)}.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'getup') {
                // Animation de r√©cup√©ration (4 frames)
                spritePath = `ninja_getup${Math.min(frame, 4)}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                spritePath = `ninja_hurt${Math.min(frame, 2)}.png`;
                return sprites[spritePath] || null;
            } else if (animationState === 'special') {
                spritePath = `special/ninja_special${frame}.png`;
                if (sprites[spritePath]) return sprites[spritePath];
                
                const attackFrame = Math.min(frame, 3);
                spritePath = `ninja_attack${attackFrame}.png`;
                return sprites[spritePath] || null;
            } else {
                spritePath = `ninja_${animationState}${frame}.png`;
            }
            
            return sprites[spritePath] || null;
        }

        // Classe pour les effets visuels d'impact
        class ImpactEffect {
            constructor(x, y, type, duration = 300) {
                this.x = x;
                this.y = y;
                this.type = type; // 'hit', 'critical', 'knockdown'
                this.duration = duration;
                this.timer = duration;
                this.size = 0;
                this.maxSize = type === 'knockdown' ? 80 : type === 'critical' ? 60 : 40;
                this.alpha = 1.0;
                this.particles = [];
                
                // Cr√©er des particules pour l'effet
                const particleCount = type === 'knockdown' ? 12 : type === 'critical' ? 8 : 5;
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: 0,
                        y: 0,
                        vx: (Math.random() - 0.5) * 200,
                        vy: (Math.random() - 0.5) * 200,
                        life: 1.0,
                        size: Math.random() * 6 + 2
                    });
                }
            }
            
            update(deltaTime) {
                this.timer -= deltaTime * 1000;
                const progress = 1 - (this.timer / this.duration);
                
                // Animation de taille (expansion puis contraction)
                if (progress < 0.3) {
                    this.size = (progress / 0.3) * this.maxSize;
                } else {
                    this.size = this.maxSize * (1 - (progress - 0.3) / 0.7);
                }
                
                this.alpha = Math.max(0, 1 - progress);
                
                // Mettre √† jour les particules
                this.particles.forEach(p => {
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    p.life -= deltaTime * 2; // Dur√©e de vie des particules
                });
                
                return this.timer > 0;
            }
            
            render(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                
                // Effet principal selon le type
                ctx.translate(this.x, this.y);
                
                if (this.type === 'knockdown') {
                    // Effet rouge intense pour knockdown
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, 'rgba(255, 50, 50, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 100, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 150, 150, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    
                    // Lignes d'impact
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * this.size * 0.8, Math.sin(angle) * this.size * 0.8);
                        ctx.stroke();
                    }
                } else if (this.type === 'critical') {
                    // Effet jaune pour coup critique
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, 'rgba(255, 255, 50, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 150, 50, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                } else if (this.type === 'special_explosion') {
                    // Effet SPECTACULAIRE pour attaque sp√©ciale ninja !
                    const progress = 1 - (this.timer / this.duration);
                    
                    // Explosion principale avec d√©grad√© arc-en-ciel
                    const gradient1 = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient1.addColorStop(0, 'rgba(255, 255, 255, 1.0)'); // Centre blanc pur
                    gradient1.addColorStop(0.2, 'rgba(255, 100, 255, 0.9)'); // Magenta intense
                    gradient1.addColorStop(0.4, 'rgba(100, 255, 255, 0.7)'); // Cyan brillant
                    gradient1.addColorStop(0.6, 'rgba(255, 255, 100, 0.5)'); // Jaune √©lectrique
                    gradient1.addColorStop(0.8, 'rgba(255, 100, 100, 0.3)'); // Rouge √©nerg√©tique
                    gradient1.addColorStop(1, 'rgba(100, 100, 255, 0)'); // Bleu qui dispara√Æt
                    ctx.fillStyle = gradient1;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    
                    // Cercles d'√©nergie pulsants
                    for (let i = 0; i < 4; i++) {
                        const ringSize = this.size * (0.3 + i * 0.2) * (1 + Math.sin(progress * Math.PI * 4 + i) * 0.1);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 - i * 0.15})`;
                        ctx.lineWidth = 4 - i;
                        ctx.beginPath();
                        ctx.arc(0, 0, ringSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Rayons d'√©nergie rotatifs
                    for (let i = 0; i < 16; i++) {
                        const angle = (i / 16) * Math.PI * 2 + progress * Math.PI * 2;
                        const length = this.size * (0.8 + Math.sin(progress * Math.PI * 8 + i) * 0.2);
                        ctx.strokeStyle = `rgba(255, ${200 + Math.sin(angle) * 55}, 255, ${0.7 - (i % 4) * 0.1})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * length, Math.sin(angle) * length);
                        ctx.stroke();
                    }
                } else if (this.type === 'blocked') {
                    // Effet cyan pour attaque bloqu√©e
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(100, 255, 255, 0.4)');
                    gradient.addColorStop(1, 'rgba(150, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    
                    // Effet de bouclier
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.9)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Effet bleu pour coup normal
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, 'rgba(100, 150, 255, 0.6)');
                    gradient.addColorStop(0.5, 'rgba(150, 200, 255, 0.3)');
                    gradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                }
                
                // Rendre les particules
                this.particles.forEach(p => {
                    if (p.life > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${p.life})`;
                        ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                    }
                });
                
                ctx.restore();
            }
        }

        // Classe Projectile
        class FixedProjectile {
            constructor(x, y, direction, owner) {
                this.x = x;
                this.y = y + 30;
                this.width = 80;  // Plus grand pour vos nouveaux sprites !
                this.height = 40; // Plus grand pour vos nouveaux sprites !
                this.direction = direction;
                this.speed = 500;
                this.damage = 40;
                this.owner = owner;
                this.timer = 0;
                this.life = 3000;
                this.glowIntensity = 1.0;
                this.trail = []; // Tableau pour stocker les positions de la tra√Æn√©e
                this.trailMaxLength = 20; // Tra√Æn√©e MEGA spectaculaire !
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000;
                
                // Ajouter la position actuelle √† la tra√Æn√©e
                this.trail.push({
                    x: this.x + this.width / 2,  // Centre du projectile
                    y: this.y + this.height / 2,
                    alpha: 1.0  // Transparence initiale
                });
                
                // Limiter la longueur de la tra√Æn√©e
                if (this.trail.length > this.trailMaxLength) {
                    this.trail.shift();  // Supprimer le plus ancien
                }
                
                // Diminuer la transparence des anciennes positions
                for (let i = 0; i < this.trail.length; i++) {
                    this.trail[i].alpha = (i + 1) / this.trail.length;
                }
                
                this.x += this.speed * this.direction * dt;
                this.timer += deltaTime;
                this.glowIntensity = 0.5 + 0.5 * Math.sin(this.timer * 0.01);
                
                return !(this.x < -100 || this.x > 1300 || this.timer > this.life);
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            render(ctx) {
                // === TRA√éN√âE SPECTACULAIRE === (derri√®re le projectile)
                ctx.save();
                for (let i = 0; i < this.trail.length - 1; i++) {
                    const current = this.trail[i];
                    const progress = current.alpha;
                    
                    // Taille variable de la tra√Æn√©e (plus grosse au d√©but)
                    const size = (progress * 25) + 8;
                    const alpha = progress * 0.8;
                    
                    // Effet de double cercle pour plus de profondeur
                    ctx.globalAlpha = alpha;
                    
                    // Cercle ext√©rieur (halo)
                    ctx.fillStyle = `rgba(0, 150, 255, ${alpha * 0.3})`;
                    ctx.shadowColor = 'cyan';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(current.x, current.y, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cercle int√©rieur (c≈ìur brillant)
                    ctx.fillStyle = `rgba(100, 255, 255, ${alpha})`;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(current.x, current.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Point central ultra-brillant
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(current.x, current.y, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                
                // === PROJECTILE PURE √âNERGIE === (point focal de la tra√Æn√©e)
                ctx.save();
                
                // NOYAU CENTRAL ULTRA-BRILLANT
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Halo externe pulsant
                const pulseSize = 35 + Math.sin(this.timer * 0.01) * 10;
                ctx.shadowColor = 'rgba(0, 255, 255, 0.8)';
                ctx.shadowBlur = 50 * this.glowIntensity;
                ctx.fillStyle = `rgba(0, 150, 255, ${0.2 * this.glowIntensity})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Noyau principal
                ctx.shadowBlur = 30;
                ctx.fillStyle = `rgba(50, 255, 255, ${0.8 * this.glowIntensity})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // C≈ìur ultra-brillant
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 20;
                ctx.fillStyle = `rgba(255, 255, 255, ${this.glowIntensity})`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Point central pur
                ctx.shadowBlur = 10;
                ctx.fillStyle = `rgba(255, 255, 255, 1.0)`;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // Classe joueur avec sprites fixes
        class FixedPlayer {
            constructor(x, y, type, isPlayer1) {
                this.x = x;
                this.y = y;
                this.width = 80;
                this.height = 80;
                this.type = type;
                this.isPlayer1 = isPlayer1;
                this.health = 100;
                this.maxHealth = 100;
                this.facingLeft = false;
                
                this.animationState = 'idle';
                this.animationFrame = 1;
                this.animationTimer = 0;
                this.frameSpeed = 300;
                
                this.vx = 0;
                this.vy = 0;
                this.onGround = false;
                this.speed = 300;
                this.jumpPower = 500;
                this.gravity = 1500;
                
                this.isAttacking = false;
                this.attackTimer = 0;
                this.attackDuration = 1000;
                this.hasHit = false;
                
                // Syst√®me sp√©cial
                this.isChargingSpecial = false;
                this.specialPhase = 0;
                this.specialTimer = 0;
                this.specialPhaseDurations = [0, 300, 300, 300, 200, 250, 250];
                this.specialCooldown = 0;
                this.specialCooldownDuration = 3000;
                
                // Syst√®me de combos
                this.comboType = 'normal'; // 'normal', 'uppercut', 'low'
                this.lastAttackTime = 0;
                this.comboWindow = 600; // 600ms pour encha√Æner G+G (plus facile)
                this.isDoubleAttack = false;
                this.doubleAttackTimer = 0;
                
                // Debug visual
                this.debugText = "";
                this.debugTimer = 0;
                this.doubleAttackDuration = 600;
                
                // Syst√®me hurt am√©lior√©
                this.isHurt = false;
                this.hurtTimer = 0;
                
                // Syst√®me de chute au sol
                this.isDown = false;
                this.downTimer = 0;
                this.downDuration = 500; // 0.5 seconde au sol (encore r√©duit de moiti√©)
                
                // Syst√®me de r√©cup√©ration
                this.isGettingUp = false;
                this.getupTimer = 0;
                this.getupDuration = 900; // 0.9 secondes pour se relever (plus r√©aliste)
                
                // Syst√®me de dash
                this.isDashing = false;
                this.dashTimer = 0;
                this.dashDuration = 400; // 0.4 secondes de dash (plus long et jouable)
                this.dashSpeed = 500; // Vitesse du dash (un peu r√©duite)
                this.dashCooldown = 0;
                this.dashCooldownDuration = 1000; // 1 seconde entre chaque dash
                this.dashDirection = 0; // -1 gauche, 1 droite
                
                // Syst√®me de garde
                this.isBlocking = false;
                this.blockStun = 0;
                this.blockStunDuration = 300; // 0.3 secondes de stun apr√®s avoir bloqu√©
                this.blockDirection = 0; // Direction de la garde
            }
            
            chargeSpecialAttack() {
                if (this.specialCooldown <= 0 && !this.isChargingSpecial) {
                    this.isChargingSpecial = true;
                    this.specialPhase = 1;
                    this.specialTimer = 0;
                    this.animationState = 'special';
                    this.updatePhaseDisplay();
                    console.log(`${this.type} : D√©but technique sp√©ciale !`);
                }
            }
            
            updatePhaseDisplay() {
                const phaseNames = ['Normal', 'Concentration', 'Accumulation', 'Charge Max', 'LANCEMENT!', 'R√©cup√©ration', 'Fin'];
                document.getElementById('specialPhase').textContent = `${this.type} - ${phaseNames[this.specialPhase]}`;
            }
            
            executeSpecialAttack() {
                const projectileX = this.facingLeft ? this.x - 40 : this.x + this.width;
                const projectileY = this.y;
                const direction = this.facingLeft ? -1 : 1;
                
                const projectile = new FixedProjectile(projectileX, projectileY, direction, this);
                projectiles.push(projectile);
                
                timeScale = 0.3;
                console.log(`${this.type} : HADOKEN lanc√© !`);
                
                setTimeout(() => { timeScale = 1.0; }, 1000);
            }
            
            // Syst√®me de dash
            startDash(direction) {
                if (this.dashCooldown <= 0 && !this.isDashing && !this.isAttacking && !this.isHurt && !this.isDown) {
                    this.isDashing = true;
                    this.dashTimer = 0;
                    this.dashDirection = direction;
                    this.dashCooldown = this.dashCooldownDuration;
                    this.animationState = 'dash'; // Utilise l'animation de dash sp√©cifique
                    this.animationFrame = 1; // Commencer √† la frame 1
                    console.log(`${this.type} : Dash ${direction > 0 ? 'droite' : 'gauche'} !`);
                }
            }
            
            // Syst√®me de garde
            startBlocking(direction) {
                if (!this.isAttacking && !this.isHurt && !this.isDown && !this.isDashing && this.blockStun <= 0) {
                    this.isBlocking = true;
                    this.blockDirection = direction;
                    this.animationState = 'shield'; // Utilise l'animation de shield sp√©cifique
                    this.animationFrame = 1; // Commencer √† la frame 1
                }
            }
            
            stopBlocking() {
                this.isBlocking = false;
            }
            
            // Obtenir la vitesse d'animation selon l'√©tat actuel
            getCurrentFrameSpeed() {
                switch (this.animationState) {
                    case 'dash':
                        return 200; // Animation normale pour le dash
                    case 'shield':
                        return 500; // Animation plus lente en garde
                    case 'attack':
                    case 'uppercut':
                    case 'low':
                    case 'double':
                        return 300; // Vitesse normale pour les attaques
                    case 'idle':
                        return 300; // Vitesse normale pour idle
                    case 'walk':
                        return 250; // L√©g√®rement plus rapide pour la marche
                    case 'hurt':
                        return 400; // Plus lent pour hurt
                    default:
                        return 300; // Vitesse par d√©faut
                }
            }

            update(deltaTime) {
                const dt = deltaTime / 1000;
                const scaledDeltaTime = deltaTime * timeScale;
                const scaledDt = dt * timeScale;
                
                if (this.specialCooldown > 0) {
                    this.specialCooldown -= deltaTime;
                }
                
                // Gestion des cooldowns
                if (this.dashCooldown > 0) {
                    this.dashCooldown -= deltaTime;
                }
                
                if (this.blockStun > 0) {
                    this.blockStun -= deltaTime;
                }
                
                // Gestion du dash
                if (this.isDashing) {
                    this.dashTimer += deltaTime;
                    this.vx = this.dashDirection * this.dashSpeed;
                    
                    if (this.dashTimer >= this.dashDuration) {
                        this.isDashing = false;
                        this.dashTimer = 0;
                        this.animationState = 'idle'; // Retour √† l'√©tat idle
                        this.animationFrame = 1;
                    }
                }
                
                if (this.isChargingSpecial) {
                    this.specialTimer += deltaTime;
                    
                    const currentPhaseDuration = this.specialPhaseDurations[this.specialPhase];
                    
                    if (this.specialTimer >= currentPhaseDuration) {
                        this.specialTimer = 0;
                        this.specialPhase++;
                        
                        if (this.specialPhase === 4) {
                            this.executeSpecialAttack();
                        } else if (this.specialPhase > 6) {
                            this.isChargingSpecial = false;
                            this.specialPhase = 0;
                            this.specialCooldown = this.specialCooldownDuration;
                            this.animationState = 'idle';
                            this.animationFrame = 1; // CORRECTION: Commencer √† 1, pas 0
                        }
                        
                        this.updatePhaseDisplay();
                        if (this.isChargingSpecial) {
                            this.animationFrame = this.specialPhase;
                        }
                    }
                    
                    return;
                }
                
                let isMoving = false;
                
                // Emp√™cher toute action si le joueur est au sol ou se rel√®ve
                if (!this.isDown && !this.isGettingUp) {
                    if (this.isPlayer1) {
                        // Syst√®me de garde (S pour bloquer)
                        if (keys['KeyS'] && !this.isDashing) {
                            const guardDirection = this.facingLeft ? -1 : 1;
                            this.startBlocking(guardDirection);
                        } else if (!keys['KeyS']) {
                            this.stopBlocking();
                        }
                        
                        // Syst√®me de dash (double tap ou Q/E)
                        if (keys['KeyQ'] && !this.isBlocking) {
                            this.startDash(-1); // Dash gauche
                        } else if (keys['KeyE'] && !this.isBlocking) {
                            this.startDash(1); // Dash droite
                        }
                        
                        // Mouvements normaux (d√©sactiv√©s pendant dash et garde)
                        if (!this.isDashing && !this.isBlocking) {
                            if (keys['KeyA']) {
                                this.vx = -this.speed;
                                this.facingLeft = true;
                                isMoving = true;
                            } else if (keys['KeyD']) {
                                this.vx = this.speed;
                                this.facingLeft = false;
                                isMoving = true;
                            } else {
                                this.vx = 0;
                            }
                        }
                        
                        if (keys['KeyW'] && this.onGround && !this.isBlocking) {
                            this.vy = -this.jumpPower;
                            this.onGround = false;
                        }
                        
                        // Touches d'attaque et combos (bloqu√©es pendant garde)
                        if (keys['KeyG'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                        if (keys['KeyU'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                        if (keys['KeyF'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            console.log("üî• JOUEUR 1 - TOUCHE F PRESS√âE!");
                            this.handleComboAttack();
                        }
                    } else {
                        // Syst√®me de garde (ArrowDown pour bloquer)
                        if (keys['ArrowDown'] && !this.isDashing) {
                            const guardDirection = this.facingLeft ? -1 : 1;
                            this.startBlocking(guardDirection);
                        } else if (!keys['ArrowDown']) {
                            this.stopBlocking();
                        }
                        
                        // Syst√®me de dash (Digit0 et Enter)
                        if (keys['Digit0'] && !this.isBlocking) {
                            this.startDash(-1); // Dash gauche
                        } else if (keys['Enter'] && !this.isBlocking) {
                            this.startDash(1); // Dash droite
                        }
                        
                        // Mouvements normaux (d√©sactiv√©s pendant dash et garde)
                        if (!this.isDashing && !this.isBlocking) {
                            if (keys['ArrowLeft']) {
                                this.vx = -this.speed;
                                this.facingLeft = true;
                                isMoving = true;
                            } else if (keys['ArrowRight']) {
                                this.vx = this.speed;
                                this.facingLeft = false;
                                isMoving = true;
                            } else {
                                this.vx = 0;
                            }
                        }
                        
                        if (keys['ArrowUp'] && this.onGround && !this.isBlocking) {
                            this.vy = -this.jumpPower;
                            this.onGround = false;
                        }
                        
                        // Touches d'attaque et combos (bloqu√©es pendant garde)
                        if (keys['KeyL'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                        if (keys['KeyU'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                        if (keys['KeyF'] && !this.isAttacking && !this.isHurt && !this.isBlocking) {
                            this.handleComboAttack();
                        }
                    }
                }
                
                this.vy += this.gravity * scaledDt;
                
                // Appliquer la friction horizontale (surtout au sol)
                if (this.onGround) {
                    const friction = this.isDown ? 0.85 : 0.92; // Plus de friction quand knockdown
                    this.vx *= friction;
                    
                    // Arr√™ter compl√®tement si la vitesse devient tr√®s faible
                    if (Math.abs(this.vx) < 5) {
                        this.vx = 0;
                    }
                }
                
                this.x += this.vx * scaledDt;
                this.y += this.vy * scaledDt;
                
                if (this.y >= 620) {
                    this.y = 620;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                
                this.updateAnimation(scaledDeltaTime, isMoving);
                
                // Gestion du timer de double attaque
                if (this.isDoubleAttack) {
                    this.doubleAttackTimer += scaledDeltaTime;
                    if (this.doubleAttackTimer >= this.doubleAttackDuration) {
                        this.isDoubleAttack = false;
                        this.doubleAttackTimer = 0;
                    }
                }
                
                if (this.isAttacking) {
                    this.attackTimer += scaledDeltaTime;
                    if (this.attackTimer >= this.attackDuration) {
                        this.isAttacking = false;
                        this.attackTimer = 0;
                        this.hasHit = false;
                        this.comboType = 'normal'; // Reset combo type
                    }
                }
            }
            
            updateAnimation(deltaTime, isMoving) {
                // Gestion des timers
                if (this.hurtTimer > 0) {
                    this.hurtTimer -= deltaTime;
                    if (this.hurtTimer <= 0) {
                        this.isHurt = false;
                    }
                }
                
                let newState;
                
                // Debug pour voir l'√©tat actuel
                if (this.isDown) {
                    console.log(`üîç ${this.type}: isDown=${this.isDown}, downTimer=${this.downTimer}`);
                }
                
                // G√©rer les √©tats dans le bon ordre
                if (this.isDown && this.downTimer > 0) {
                    // D√©cr√©menter le timer pendant qu'on est au sol (deltaTime est d√©j√† en millisecondes)
                    this.downTimer -= deltaTime;
                    newState = 'down'; // √âtat au sol
                    console.log(`DEBUG: ${this.type} is DOWN - Timer: ${this.downTimer.toFixed(0)}`);
                    
                    if (this.downTimer <= 0) {
                        // Passer √† la phase de r√©cup√©ration
                        this.isDown = false;
                        this.isGettingUp = true;
                        this.getupTimer = this.getupDuration;
                        console.log(`${this.type}: D√©but de la r√©cup√©ration`);
                    }
                } else if (this.isGettingUp && this.getupTimer > 0) {
                    // D√©cr√©menter le timer pendant qu'on se rel√®ve (deltaTime est d√©j√† en millisecondes)
                    this.getupTimer -= deltaTime;
                    newState = 'getup'; // √âtat de r√©cup√©ration
                    console.log(`DEBUG: ${this.type} is GETTING UP - Timer: ${this.getupTimer.toFixed(0)}`);
                    
                    if (this.getupTimer <= 0) {
                        this.isGettingUp = false;
                        console.log(`${this.type}: R√©cup√©ration termin√©e`);
                    }
                } else if (this.isHurt) {
                    newState = 'hurt'; // √âtat bless√©
                } else if (this.isChargingSpecial) {
                    newState = 'special';
                } else if (this.isAttacking) {
                    // Utiliser l'√©tat d'animation d√©fini par le combo au lieu de forcer 'attack'
                    newState = this.animationState; // Garder l'√©tat actuel (uppercut, low, double, attack)
                } else if (!this.onGround) {
                    newState = 'jump';
                } else if (isMoving) {
                    newState = 'walk';
                } else {
                    newState = 'idle';
                }
                
                if (newState !== this.animationState) {
                    this.animationState = newState;
                    this.animationFrame = 1;
                    this.animationTimer = 0;
                }
                
                this.animationTimer += deltaTime;
                
                // Obtenir la vitesse d'animation selon l'√©tat actuel
                const currentFrameSpeed = this.getCurrentFrameSpeed();
                
                if (this.animationTimer >= currentFrameSpeed) {
                    this.animationTimer = 0;
                    
                    if (!this.isChargingSpecial) {
                        this.animationFrame++;
                        
                        const maxFrames = {
                            'idle': 3, 'walk': 4, 'jump': 2, 'attack': 3, 'hurt': 2, 'special': 6,
                            'uppercut': 3, 'low': 3, 'double': 3, 'down': 3, 'getup': 4,
                            'dash': 3, 'shield': 3
                        };
                        
                        const maxFrame = maxFrames[this.animationState] || 1;
                        if (this.animationFrame > maxFrame) {
                            this.animationFrame = 1;
                        }
                    }
                }
            }
            
            handleComboAttack() {
                const currentTime = Date.now();
                const timeSinceLastAttack = currentTime - this.lastAttackTime;
                
                // D√©tection des combos selon les touches press√©es
                if (keys['KeyU']) {
                    // Uppercut (U)
                    this.comboType = 'uppercut';
                    this.attack();
                    console.log(`${this.type}: UPPERCUT!`);
                } else if (keys['KeyF']) {
                    // Attaque basse (F)
                    this.comboType = 'low';
                    this.attack();
                    console.log(`üî• ${this.type}: ATTAQUE BASSE - LOW ATTACK!`);
                } else if (timeSinceLastAttack < this.comboWindow && timeSinceLastAttack > 50) {
                    // Double frappe (G+G) - d√©tection am√©lior√©e
                    this.comboType = 'double';
                    this.isDoubleAttack = true;
                    this.doubleAttackTimer = 0;
                    this.attack();
                    console.log(`${this.type}: DOUBLE FRAPPE! (timing: ${timeSinceLastAttack}ms)`);
                } else {
                    // Attaque normale
                    this.comboType = 'normal';
                    this.attack();
                    console.log(`${this.type}: ATTAQUE NORMALE (timing: ${timeSinceLastAttack}ms)`);
                }
                
                this.lastAttackTime = currentTime;
            }
            
            attack() {
                this.isAttacking = true;
                this.attackTimer = 0;
                this.hasHit = false;
                
                // D√©finir l'√©tat d'animation selon le type de combo
                switch(this.comboType) {
                    case 'uppercut':
                        this.animationState = 'uppercut';
                        this.attackDuration = 700; // Uppercut un peu plus long
                        console.log(`${this.type}: Animation UPPERCUT activ√©e!`);
                        // Debug visible √† l'√©cran
                        this.debugText = "UPPERCUT!";
                        this.debugTimer = 60;
                        break;
                    case 'low':
                        this.animationState = 'low';
                        this.attackDuration = 600; // Attaque basse rapide
                        console.log(`${this.type}: Animation LOW activ√©e!`);
                        // Debug visible √† l'√©cran
                        this.debugText = "LOW ATTACK!";
                        this.debugTimer = 60;
                        break;
                    case 'double':
                        this.animationState = 'double';
                        this.attackDuration = 800; // Plus long pour double frappe
                        console.log(`${this.type}: Animation DOUBLE activ√©e!`);
                        // Debug visible √† l'√©cran
                        this.debugText = "DOUBLE HIT!";
                        this.debugTimer = 60;
                        break;
                    default:
                        this.animationState = 'attack';
                        this.attackDuration = 500; // Attaque normale
                        console.log(`${this.type}: Animation ATTACK normale`);
                        // Debug visible √† l'√©cran
                        this.debugText = "NORMAL ATTACK";
                        this.debugTimer = 60;
                }
                
                // Reset de l'animation
                this.animationFrame = 1;
            }
            
            takeDamage(amount, attackerX = null, knockdownType = null) {
                // V√©rifier si l'attaque est bloqu√©e
                if (this.isBlocking && attackerX !== null) {
                    // D√©terminer la direction de l'attaque
                    const attackFromLeft = attackerX < this.x;
                    const attackFromRight = attackerX > this.x;
                    
                    // V√©rifier si la garde est dans la bonne direction
                    const guardingCorrectDirection = 
                        (attackFromLeft && this.blockDirection < 0) || 
                        (attackFromRight && this.blockDirection > 0);
                    
                    if (guardingCorrectDirection) {
                        // Attaque bloqu√©e !
                        this.blockStun = this.blockStunDuration;
                        this.health -= Math.floor(amount * 0.2); // Seulement 20% des d√©g√¢ts
                        this.health = Math.max(0, this.health);
                        
                        // Petit recul lors du block
                        const pushback = attackFromLeft ? 50 : -50;
                        this.vx = pushback;
                        
                        console.log(`${this.type} : Attaque bloqu√©e ! D√©g√¢ts r√©duits.`);
                        return true; // Attaque bloqu√©e
                    }
                }
                
                // Attaque non bloqu√©e - d√©g√¢ts normaux
                this.health -= amount;
                this.health = Math.max(0, this.health);
                
                // Arr√™ter la garde si on prend des d√©g√¢ts
                this.stopBlocking();
                
                // Ne pas forcer l'√©tat hurt si on est d√©j√† knockdown
                // Le knockdown aura priorit√© sur l'animation hurt
                if (!this.isDown) {
                    // √âtat de hurt plus long et visible
                    this.animationState = 'hurt';
                    this.animationFrame = 1;
                    this.hurtTimer = 800; // Dur√©e d'√©tat hurt (800ms)
                    this.isHurt = true;
                }
                
                // Interruption des actions en cours
                this.isAttacking = false;
                this.isChargingSpecial = false;
                this.isDashing = false;
                
                return false; // Attaque non bloqu√©e
            }
            
            render(ctx) {
                // Obtenir le sprite
                const sprite = getSprite(this.animationState, this.animationFrame);
                
                if (sprite) {
                    ctx.save();
                    
                    // Taille standardis√©e pour tous les sprites ninja
                    let renderWidth = this.width;
                    let renderHeight = this.height;
                    
                    if (this.type.toLowerCase().includes('ninja')) {
                        // Forcer une taille constante pour tous les sprites ninja
                        renderWidth = 80;  // Taille fixe largeur
                        renderHeight = 80; // Taille fixe hauteur
                    }
                    
                    if (this.facingLeft) {
                        ctx.scale(-1, 1);
                        ctx.drawImage(sprite, -this.x - renderWidth, this.y, renderWidth, renderHeight);
                    } else {
                        ctx.drawImage(sprite, this.x, this.y, renderWidth, renderHeight);
                    }
                    ctx.restore();
                } else {
                    // Fallback rectangle
                    ctx.fillStyle = this.isPlayer1 ? 'blue' : 'red';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // Indicateur sprite manquant
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${this.animationState}${this.animationFrame}`, this.x + this.width/2, this.y + this.height/2);
                }
                
                // Affichage debug combo
                if (this.debugTimer > 0) {
                    ctx.save();
                    ctx.fillStyle = 'yellow';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.strokeText(this.debugText, this.x + this.width/2, this.y - 30);
                    ctx.fillText(this.debugText, this.x + this.width/2, this.y - 30);
                    
                    this.debugTimer -= 16.67; // ~60fps
                    if (this.debugTimer <= 0) {
                        this.debugText = "";
                    }
                }
                
                // Effet visuel de garde
                if (this.isBlocking) {
                    ctx.save();
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    
                    // Bouclier frontal
                    const shieldX = this.facingLeft ? this.x - 10 : this.x + this.width + 10;
                    const shieldY = this.y + 10;
                    const shieldWidth = 15;
                    const shieldHeight = this.height - 20;
                    
                    ctx.strokeRect(shieldX - shieldWidth/2, shieldY, shieldWidth, shieldHeight);
                    ctx.restore();
                }
                
                // Effet visuel de dash
                if (this.isDashing) {
                    ctx.save();
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([2, 2]);
                    
                    // Tra√Æn√©e de mouvement
                    for (let i = 0; i < 3; i++) {
                        const trailX = this.x - (this.dashDirection * 20 * (i + 1));
                        const alpha = 1 - (i * 0.3);
                        ctx.globalAlpha = alpha;
                        ctx.strokeRect(trailX, this.y, this.width, this.height);
                    }
                    ctx.restore();
                }
                
                // Cooldown indicators
                ctx.save();
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                
                // Dash cooldown
                if (this.dashCooldown > 0) {
                    const dashPercent = (this.dashCooldown / this.dashCooldownDuration * 100).toFixed(0);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillText(`D: ${dashPercent}%`, this.x + this.width/2, this.y - 5);
                }
                
                // Block stun
                if (this.blockStun > 0) {
                    const stunPercent = (this.blockStun / this.blockStunDuration * 100).toFixed(0);
                    ctx.fillStyle = '#FF0000';
                    ctx.fillText(`STUN: ${stunPercent}%`, this.x + this.width/2, this.y + this.height + 15);
                }
                
                ctx.restore();
                
                // Barre de vie
                const barWidth = 60;
                const barHeight = 8;
                const barX = this.x + (this.width - barWidth) / 2;
                const barY = this.y - 15;
                
                ctx.fillStyle = 'red';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                ctx.fillStyle = 'green';
                const healthWidth = (this.health / this.maxHealth) * barWidth;
                ctx.fillRect(barX, barY, healthWidth, barHeight);
                
                ctx.strokeStyle = 'white';
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // Debug visuel pour les √©tats sp√©ciaux
                if (this.isDown) {
                    ctx.save();
                    ctx.fillStyle = 'red';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.strokeText(`DOWN! ${Math.ceil(this.downTimer/1000)}s`, this.x + this.width/2, this.y - 25);
                    ctx.fillText(`DOWN! ${Math.ceil(this.downTimer/1000)}s`, this.x + this.width/2, this.y - 25);
                    ctx.restore();
                }
                
                if (this.isGettingUp) {
                    ctx.save();
                    ctx.fillStyle = 'orange';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.strokeText(`GETTING UP! ${Math.ceil(this.getupTimer/1000)}s`, this.x + this.width/2, this.y - 25);
                    ctx.fillText(`GETTING UP! ${Math.ceil(this.getupTimer/1000)}s`, this.x + this.width/2, this.y - 25);
                    ctx.restore();
                }
                
                // Indicateur phase sp√©ciale
                if (this.isChargingSpecial) {
                    ctx.save();
                    ctx.fillStyle = 'cyan';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Phase ${this.specialPhase}`, this.x + this.width/2, this.y - 30);
                    ctx.restore();
                }
                

            }
        }

        function init() {
            players = [
                new FixedPlayer(200, 620, 'Ninja Blue', true),
                new FixedPlayer(900, 620, 'Ninja Red', false)
            ];
            
            requestAnimationFrame(gameLoop);
        }

        let lastTime = 0;
        function gameLoop(currentTime) {
            if (!gameRunning) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            for (const player of players) {
                player.update(deltaTime);
            }
            
            // Mettre √† jour les effets d'impact
            for (let i = impactEffects.length - 1; i >= 0; i--) {
                const effect = impactEffects[i];
                if (!effect.update(deltaTime / 1000)) {
                    impactEffects.splice(i, 1);
                }
            }
            
            // Mettre √† jour le screen shake
            if (screenShake.duration > 0) {
                screenShake.duration -= deltaTime;
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                
                if (screenShake.duration <= 0) {
                    screenShake.x = 0;
                    screenShake.y = 0;
                }
            }
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                
                if (!projectile.update(deltaTime)) {
                    projectiles.splice(i, 1);
                    continue;
                }
                
                for (const player of players) {
                    if (projectile.owner !== player && projectile.checkCollision(player)) {
                        const wasBlocked = player.takeDamage(projectile.damage, projectile.x);
                        
                        if (!wasBlocked) {
                            player.vx = projectile.direction * 120; // R√©duit de 200 √† 120
                        }
                        
                        // Effets d'impact spectaculaires pour l'attaque sp√©ciale !
                        const impactX = player.x + player.width/2;
                        const impactY = player.y + player.height/2;
                        
                        // Explosion principale massive
                        impactEffects.push(new ImpactEffect(impactX, impactY, 'special_explosion', 1000));
                        
                        // Multiples impacts secondaires pour effet dramatique
                        setTimeout(() => {
                            impactEffects.push(new ImpactEffect(impactX - 30, impactY - 20, 'critical', 600));
                            impactEffects.push(new ImpactEffect(impactX + 25, impactY + 15, 'critical', 700));
                        }, 100);
                        
                        setTimeout(() => {
                            impactEffects.push(new ImpactEffect(impactX - 15, impactY + 30, 'hit', 400));
                            impactEffects.push(new ImpactEffect(impactX + 20, impactY - 25, 'hit', 500));
                        }, 250);
                        
                        // Screen shake ultra intense
                        screenShake = { x: 0, y: 0, intensity: 20, duration: 800 };
                        
                        console.log(`üí• SPECIAL IMPACT on ${player.type}!`);
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
            
            const [p1, p2] = players;
            const distance = Math.abs(p1.x - p2.x);
            
            if (distance < 100) {
                if (p1.isAttacking && !p1.hasHit && p1.animationFrame >= 2) {
                    // V√©rifier que p1 attaque dans la bonne direction
                    const isHitting = p1.facingLeft ? (p2.x < p1.x) : (p2.x > p1.x);
                    
                    if (isHitting) {
                        let damage = calculateComboDamage(p1);
                        let knockback = calculateComboKnockback(p1);
                        
                        // Calcul du point d'impact pr√©cis (style Tekken)
                        const impactX = p2.x + p2.width/2; // Centre du receveur
                        const impactY = p2.y + p2.height/3; // Partie haute du corps
                        
                        // Appliquer les effets sp√©ciaux AVANT takeDamage pour √©viter animation double
                        if (p1.comboType === 'low') {
                            // Low attack met l'adversaire au sol !
                            p2.isDown = true;
                            p2.downTimer = p2.downDuration;
                            p2.vy = 0; // Pas de projection verticale
                            p2.vx = (p2.x > p1.x ? 100 : -100); // R√©duit de 200 √† 100 pour knockdown
                            console.log(`üî• ${p2.type}: KNOCKED DOWN! Timer=${p2.downTimer} - isDown=${p2.isDown}`);
                            // Effet d'impact knockdown sur les jambes/bas du corps
                            const lowImpactY = p2.y + (p2.height * 2/3);
                            impactEffects.push(new ImpactEffect(impactX, lowImpactY, 'knockdown', 800));
                            // Screen shake intense pour knockdown
                            screenShake = { x: 0, y: 0, intensity: 12, duration: 500 };
                        }
                        
                        // Appliquer les d√©g√¢ts APR√àS les effets sp√©ciaux
                        const wasBlocked = p2.takeDamage(damage, p1.x, p1.comboType);
                        
                        if (!wasBlocked) {
                            p1.hasHit = true;
                            
                            // Effets selon le type de combo
                            if (p1.comboType === 'uppercut') {
                                p2.vy = -400; // Projette vers le haut
                                p2.vx = (p2.x > p1.x ? 120 : -120);
                                impactEffects.push(new ImpactEffect(impactX, impactY, 'critical', 500));
                                screenShake = { x: 0, y: 0, intensity: 8, duration: 300 };
                            } else if (p1.comboType === 'double') {
                                p2.vx = (p2.x > p1.x ? knockback * 1.2 : -knockback * 1.2);
                                impactEffects.push(new ImpactEffect(impactX - 10, impactY, 'critical', 400));
                                setTimeout(() => {
                                    impactEffects.push(new ImpactEffect(impactX + 10, impactY + 15, 'critical', 400));
                                }, 150);
                                screenShake = { x: 0, y: 0, intensity: 6, duration: 200 };
                                setTimeout(() => {
                                    screenShake = { x: 0, y: 0, intensity: 8, duration: 300 };
                                }, 150);
                            } else if (p1.comboType !== 'low') { // Low attack d√©j√† g√©r√©
                                p2.vx = (p2.x > p1.x ? knockback : -knockback);
                                impactEffects.push(new ImpactEffect(impactX, impactY + 10, 'hit', 350));
                                screenShake = { x: 0, y: 0, intensity: 4, duration: 150 };
                            }
                        } else {
                            // Effet de garde r√©ussie
                            impactEffects.push(new ImpactEffect(impactX, impactY, 'blocked', 300));
                            screenShake = { x: 0, y: 0, intensity: 3, duration: 150 };
                        }
                        
                        // Affichage du type d'attaque
                        showComboNotification(p1);
                    }
                }
                if (p2.isAttacking && !p2.hasHit && p2.animationFrame >= 2) {
                    // V√©rifier que p2 attaque dans la bonne direction
                    const isHitting = p2.facingLeft ? (p1.x < p2.x) : (p1.x > p2.x);
                    
                    if (isHitting) {
                        let damage = calculateComboDamage(p2);
                        let knockback = calculateComboKnockback(p2);
                        
                        // Calcul du point d'impact pr√©cis (style Tekken)
                        const impactX = p1.x + p1.width/2; // Centre du receveur
                        const impactY = p1.y + p1.height/3; // Partie haute du corps
                        
                        // Appliquer les effets sp√©ciaux AVANT takeDamage pour √©viter animation double
                        if (p2.comboType === 'low') {
                            // Low attack met l'adversaire au sol !
                            p1.isDown = true;
                            p1.downTimer = p1.downDuration;
                            p1.vy = 0; // Pas de projection verticale
                            p1.vx = (p1.x > p2.x ? 100 : -100); // R√©duit de 200 √† 100 pour knockdown
                            console.log(`${p1.type}: KNOCKED DOWN!`);
                            // Effet d'impact knockdown sur les jambes/bas du corps
                            const lowImpactY = p1.y + (p1.height * 2/3);
                            impactEffects.push(new ImpactEffect(impactX, lowImpactY, 'knockdown', 800));
                            // Screen shake intense pour knockdown
                            screenShake = { x: 0, y: 0, intensity: 12, duration: 500 };
                        }
                        
                        // Appliquer les d√©g√¢ts APR√àS les effets sp√©ciaux
                        const wasBlocked = p1.takeDamage(damage, p2.x, p2.comboType);
                        
                        if (!wasBlocked) {
                            p2.hasHit = true;
                            
                            // Effets selon le type de combo
                            if (p2.comboType === 'uppercut') {
                                p1.vy = -400; // Projette vers le haut
                                p1.vx = (p1.x > p2.x ? 120 : -120);
                                impactEffects.push(new ImpactEffect(impactX, impactY, 'critical', 500));
                                screenShake = { x: 0, y: 0, intensity: 8, duration: 300 };
                            } else if (p2.comboType === 'double') {
                                p1.vx = (p1.x > p2.x ? knockback * 1.2 : -knockback * 1.2);
                                impactEffects.push(new ImpactEffect(impactX - 10, impactY, 'critical', 400));
                                setTimeout(() => {
                                    impactEffects.push(new ImpactEffect(impactX + 10, impactY + 15, 'critical', 400));
                                }, 150);
                                screenShake = { x: 0, y: 0, intensity: 6, duration: 200 };
                                setTimeout(() => {
                                    screenShake = { x: 0, y: 0, intensity: 8, duration: 300 };
                                }, 150);
                            } else if (p2.comboType !== 'low') { // Low attack d√©j√† g√©r√©
                                p1.vx = (p1.x > p2.x ? knockback : -knockback);
                                impactEffects.push(new ImpactEffect(impactX, impactY + 10, 'hit', 350));
                                screenShake = { x: 0, y: 0, intensity: 4, duration: 150 };
                            }
                        } else {
                            // Effet de garde r√©ussie
                            impactEffects.push(new ImpactEffect(impactX, impactY, 'blocked', 300));
                            screenShake = { x: 0, y: 0, intensity: 3, duration: 150 };
                        }
                        
                        // Affichage du type d'attaque
                        showComboNotification(p2);
                    }
                }
            }
            
            document.getElementById('p1Health').textContent = Math.round(p1.health);
            document.getElementById('p2Health').textContent = Math.round(p2.health);
        }

        // Fonctions utilitaires pour les combos
        function calculateComboDamage(player) {
            switch(player.comboType) {
                case 'double': return player.isDoubleAttack ? 35 : 25; // Double frappe fait plus de d√©g√¢ts
                case 'uppercut': return 30; // Uppercut puissant
                case 'low': return 15; // Attaque basse rapide mais faible
                default: return 20; // Attaque normale
            }
        }

        function calculateComboKnockback(player) {
            switch(player.comboType) {
                case 'double': return 400; // Double frappe projette fort
                case 'uppercut': return 250; // Uppercut moyenne projection horizontale
                case 'low': return 450; // Attaque basse fait glisser
                default: return 300; // Attaque normale
            }
        }

        function showComboNotification(player) {
            // Notification temporaire (√† am√©liorer visuellement plus tard)
            const comboNames = {
                'double': 'DOUBLE HIT!',
                'uppercut': 'UPPERCUT!',
                'low': 'LOW ATTACK!',
                'normal': 'HIT!'
            };
            
            console.log(`${player.type}: ${comboNames[player.comboType] || 'HIT!'}`);
            
            // TODO: Ajouter affichage visuel dans le jeu
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Appliquer le screen shake
            ctx.save();
            if (screenShake.duration > 0) {
                ctx.translate(screenShake.x, screenShake.y);
            }
            
            if (timeScale < 1.0) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 100, 200, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 700, canvas.width, 100);
            
            ctx.fillStyle = '#654321';
            ctx.fillRect(300, 550, 200, 20);
            ctx.fillRect(700, 400, 200, 20);
            ctx.fillRect(500, 300, 200, 20);
            
            for (const projectile of projectiles) {
                projectile.render(ctx);
            }
            
            for (const player of players) {
                player.render(ctx);
            }
            
            // Rendre les effets d'impact par-dessus tout
            for (const effect of impactEffects) {
                effect.render(ctx);
            }
            
            if (timeScale < 1.0) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 255, 255, 0.9)';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText('‚ö° SLOW MOTION ‚ö°', canvas.width / 2, 100);
                ctx.fillText('‚ö° SLOW MOTION ‚ö°', canvas.width / 2, 100);
                ctx.restore();
            }
            
            // Restaurer le contexte du screen shake
            ctx.restore();
        }

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.shiftKey && e.code === 'KeyG') {
                e.preventDefault();
                if (players[0]) players[0].chargeSpecialAttack();
            }
            if (e.shiftKey && e.code === 'KeyL') {
                e.preventDefault();
                if (players[1]) players[1].chargeSpecialAttack();
            }
            
            if (e.code === 'KeyR') {
                location.reload();
            } else if (e.code === 'KeyP') {
                gameRunning = !gameRunning;
                if (gameRunning) requestAnimationFrame(gameLoop);
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // D√©marrer le pr√©chargement
        window.addEventListener('load', preloadSprites);
    </script>
</body>
</html>