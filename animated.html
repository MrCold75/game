<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jump Ultimate Stars - Animations Multi-Frames</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            border: 3px solid #0e4b99;
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
            box-shadow: 0 0 20px rgba(14, 75, 153, 0.5);
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        #gameInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            text-align: right;
        }
        
        .start-button {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .start-button:hover {
            background: #c0392b;
        }
        
        #log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        #loadingStatus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="controls">
            <strong>Contr√¥les:</strong><br>
            Joueur 1 (Ninja): WASD + G (attaque)<br>
            Joueur 2 (Warrior): ‚Üë‚Üì‚Üê‚Üí + L (attaque)<br>
            R: Red√©marrer | P: Pause
        </div>
        
        <div id="gameInfo">
            <div>Sant√© P1: <span id="p1Health">100</span>%</div>
            <div>Sant√© P2: <span id="p2Health">100</span>%</div>
            <div>Temps: <span id="gameTimer">99</span>s</div>
        </div>
        
        <div id="log">
            <strong>Log:</strong><br>
            <div id="logContent"></div>
        </div>
        
        <div id="loadingStatus">
            <h3>Chargement des animations...</h3>
            <div id="loadingProgress">0%</div>
        </div>
        
        <button class="start-button" onclick="startGame()">COMMENCER LE COMBAT !</button>
    </div>

    <script>
        // Variables globales
        let canvas, ctx;
        let gameRunning = false;
        let players = [];
        let keys = {};
        let lastTime = 0;
        let assetsLoaded = false;
        
        // Fonction de log
        function log(message) {
            console.log(message);
            const logContent = document.getElementById('logContent');
            logContent.innerHTML += '<div>' + new Date().toLocaleTimeString() + ': ' + message + '</div>';
            logContent.scrollTop = logContent.scrollHeight;
        }
        
        // Gestionnaire d'animations multi-frames
        class AnimationManager {
            constructor() {
                this.images = {};
                this.animations = {};
                this.loaded = 0;
                this.total = 0;
            }
            
            async loadImage(id, src) {
                return new Promise((resolve) => {
                    this.total++;
                    const img = new Image();
                    
                    img.onload = () => {
                        this.images[id] = img;
                        this.loaded++;
                        this.updateProgress();
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        // Placeholder en cas d'erreur
                        const placeholder = this.createPlaceholder(id);
                        this.images[id] = placeholder;
                        this.loaded++;
                        this.updateProgress();
                        resolve(placeholder);
                    };
                    
                    img.src = src;
                });
            }
            
            createPlaceholder(id) {
                const canvas = document.createElement('canvas');
                canvas.width = 80;
                canvas.height = 80;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(0, 0, 80, 80);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, 80, 80);
                
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('?', 40, 45);
                
                const img = new Image();
                img.src = canvas.toDataURL();
                return img;
            }
            
            updateProgress() {
                const percentage = this.total > 0 ? Math.round((this.loaded / this.total) * 100) : 0;
                document.getElementById('loadingProgress').textContent = `${percentage}% (${this.loaded}/${this.total})`;
                
                if (this.loaded === this.total) {
                    setTimeout(() => {
                        document.getElementById('loadingStatus').style.display = 'none';
                        assetsLoaded = true;
                        log('üéÆ Toutes les animations charg√©es !');
                    }, 500);
                }
            }
            
            async loadAllAnimations() {
                log('üé¨ Chargement des animations multi-frames...');
                
                // D√©finir les animations avec le nombre de frames
                const animationConfig = {
                    ninja: {
                        idle: 4,   // ninja_idle1.png √† ninja_idle4.png
                        walk: 6,   // ninja_walk1.png √† ninja_walk6.png
                        jump: 4,   // ninja_jump1.png √† ninja_jump4.png
                        attack: 4, // ninja_attack1.png √† ninja_attack4.png
                        hurt: 2    // ninja_hurt1.png √† ninja_hurt2.png
                    }
                };
                
                const loadPromises = [];
                
                for (const [character, anims] of Object.entries(animationConfig)) {
                    this.animations[character] = {};
                    
                    for (const [animName, frameCount] of Object.entries(anims)) {
                        this.animations[character][animName] = [];
                        
                        for (let i = 1; i <= frameCount; i++) {
                            const id = `${character}_${animName}_${i}`;
                            const src = `./assets/characters/${character}_${animName}${i}.png?v=${Date.now()}`;
                            
                            const promise = this.loadImage(id, src).then(img => {
                                this.animations[character][animName].push(img);
                            });
                            
                            loadPromises.push(promise);
                        }
                        
                        log(`üìã ${character}_${animName}: ${frameCount} frames`);
                    }
                }
                
                await Promise.all(loadPromises);
                log('‚úÖ Chargement termin√© !');
            }
            
            getAnimationFrame(character, animation, frameIndex) {
                if (this.animations[character] && this.animations[character][animation]) {
                    const frames = this.animations[character][animation];
                    const index = Math.floor(frameIndex) % frames.length;
                    return frames[index];
                }
                return null;
            }
            
            getFrameCount(character, animation) {
                if (this.animations[character] && this.animations[character][animation]) {
                    return this.animations[character][animation].length;
                }
                return 1;
            }
        }
        
        // Classe joueur avec animations multi-frames
        class AnimatedPlayer {
            constructor(x, y, type, isPlayer1) {
                this.x = x;
                this.y = y;
                this.width = 80;
                this.height = 80;
                this.type = type;
                this.isPlayer1 = isPlayer1;
                this.health = 100;
                this.maxHealth = 100;
                this.facingLeft = false;
                
                // Animation
                this.currentAnimation = 'idle';
                this.frameIndex = 0;
                this.animationSpeed = 0.05; // Vitesse d'animation ralentie
                this.animationTime = 0;
                this.animationLock = false; // Verrouillage pour √©viter les changements rapides
                this.animationLockTime = 0;
                
                // Physique
                this.vx = 0;
                this.vy = 0;
                this.onGround = false;
                this.speed = 300;
                this.jumpPower = 500;
                this.gravity = 1500;
                
                // Combat
                this.isAttacking = false;
                this.attackTimer = 0;
                this.attackDuration = 600; // Plus long pour voir l'animation
                this.hasHit = false;
                
                log(`ü•∑ ${type} cr√©√© avec animations multi-frames`);
            }
            
            update(deltaTime) {
                const dt = deltaTime / 1000;
                
                // Gestion du verrouillage d'animation
                if (this.animationLock) {
                    this.animationLockTime -= deltaTime;
                    if (this.animationLockTime <= 0) {
                        this.animationLock = false;
                    }
                }
                
                // Sauvegarder l'ancienne animation
                const oldAnimation = this.currentAnimation;
                
                // Input et logique d'animation
                let moving = false;
                let wantsToMove = false;
                
                if (this.isPlayer1) {
                    if (keys['KeyA']) {
                        this.vx = -this.speed;
                        this.facingLeft = true;
                        moving = true;
                        wantsToMove = true;
                    } else if (keys['KeyD']) {
                        this.vx = this.speed;
                        this.facingLeft = false;
                        moving = true;
                        wantsToMove = true;
                    } else {
                        this.vx = 0;
                    }
                    
                    if (keys['KeyW'] && this.onGround) {
                        this.vy = -this.jumpPower;
                        this.onGround = false;
                    }
                    
                    if (keys['KeyG'] && !this.isAttacking) {
                        this.attack();
                    }
                } else {
                    if (keys['ArrowLeft']) {
                        this.vx = -this.speed;
                        this.facingLeft = true;
                        moving = true;
                        wantsToMove = true;
                    } else if (keys['ArrowRight']) {
                        this.vx = this.speed;
                        this.facingLeft = false;
                        moving = true;
                        wantsToMove = true;
                    } else {
                        this.vx = 0;
                    }
                    
                    if (keys['ArrowUp'] && this.onGround) {
                        this.vy = -this.jumpPower;
                        this.onGround = false;
                    }
                    
                    if (keys['KeyL'] && !this.isAttacking) {
                        this.attack();
                    }
                }
                
                // D√©terminer l'animation seulement si pas verrouill√©e
                let newAnimation = this.currentAnimation;
                
                if (!this.animationLock) {
                    if (this.isAttacking) {
                        newAnimation = 'attack';
                    } else if (!this.onGround) {
                        newAnimation = 'jump';
                    } else if (wantsToMove && Math.abs(this.vx) > 50) {
                        newAnimation = 'walk';
                    } else {
                        newAnimation = 'idle';
                    }
                }
                
                // Changer l'animation seulement si n√©cessaire
                if (oldAnimation !== newAnimation && !this.animationLock) {
                    this.currentAnimation = newAnimation;
                    this.frameIndex = 0;
                    this.animationTime = 0;
                    
                    // Verrouiller bri√®vement pour √©viter les changements rapides
                    this.animationLock = true;
                    this.animationLockTime = 200; // 200ms de verrouillage
                }
                
                // Mettre √† jour l'animation plus lentement
                this.animationTime += deltaTime * this.animationSpeed;
                const frameCount = animationManager.getFrameCount(this.type, this.currentAnimation);
                
                // Animation en boucle stable
                if (this.animationTime >= frameCount) {
                    if (this.currentAnimation === 'attack' && this.isAttacking) {
                        // L'attaque est termin√©e
                        this.isAttacking = false;
                        this.animationLock = false;
                        this.animationTime = 0;
                        this.frameIndex = 0;
                    } else {
                        // Boucle normale
                        this.animationTime = 0;
                    }
                }
                
                this.frameIndex = Math.floor(this.animationTime) % frameCount;
                
                // Physique
                this.vy += this.gravity * dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                // Collision avec le sol
                if (this.y + this.height > 700) {
                    this.y = 700 - this.height;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                // Collision avec les bords
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > 1200) this.x = 1200 - this.width;
                
                // Combat
                if (this.isAttacking) {
                    this.attackTimer += deltaTime;
                    if (this.attackTimer >= this.attackDuration) {
                        this.isAttacking = false;
                        this.attackTimer = 0;
                        this.hasHit = false;
                    }
                }
            }
            
            attack() {
                if (this.isAttacking) return; // √âviter les attaques multiples
                
                this.isAttacking = true;
                this.attackTimer = 0;
                this.hasHit = false;
                this.currentAnimation = 'attack';
                this.frameIndex = 0;
                this.animationTime = 0;
                this.animationLock = true;
                this.animationLockTime = this.attackDuration;
                log(`‚öîÔ∏è ${this.type} lance une attaque !`);
            }
            
            takeDamage(damage) {
                this.health -= damage;
                if (this.health < 0) this.health = 0;
                
                // Animation de d√©g√¢ts seulement si pas en train d'attaquer
                if (!this.isAttacking) {
                    this.currentAnimation = 'hurt';
                    this.frameIndex = 0;
                    this.animationTime = 0;
                    this.animationLock = true;
                    this.animationLockTime = 300; // 300ms de hurt
                }
                
                log(`üí• ${this.type} prend ${damage} d√©g√¢ts ! Sant√©: ${this.health}`);
            }
            
            render(ctx) {
                if (assetsLoaded && animationManager) {
                    // Obtenir la frame actuelle
                    const frame = animationManager.getAnimationFrame(
                        this.type, 
                        this.currentAnimation, 
                        this.frameIndex
                    );
                    
                    if (frame) {
                        ctx.save();
                        
                        // Flip horizontal si n√©cessaire
                        if (this.facingLeft) {
                            ctx.scale(-1, 1);
                            ctx.drawImage(frame, -this.x - this.width, this.y, this.width, this.height);
                        } else {
                            ctx.drawImage(frame, this.x, this.y, this.width, this.height);
                        }
                        
                        ctx.restore();
                    } else {
                        // Fallback
                        this.renderRectangle(ctx);
                    }
                } else {
                    // Rendu pendant le chargement
                    this.renderRectangle(ctx);
                }
                
                // Barre de vie
                this.renderHealthBar(ctx);
                
                // Indicateur d'attaque
                if (this.isAttacking) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    const attackX = this.facingLeft ? this.x - 30 : this.x + this.width;
                    ctx.fillRect(attackX, this.y + 10, 30, 50);
                }
                
                // Debug: afficher l'animation actuelle avec plus d'infos
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.fillText(`${this.currentAnimation} ${Math.floor(this.frameIndex)+1}/${animationManager.getFrameCount(this.type, this.currentAnimation)}`, this.x, this.y - 25);
                
                // Debug: √©tat du verrouillage
                if (this.animationLock) {
                    ctx.fillStyle = 'yellow';
                    ctx.fillText(`LOCK ${Math.round(this.animationLockTime)}ms`, this.x, this.y - 10);
                }
            }
            
            renderRectangle(ctx) {
                const color = this.type === 'ninja' ? '#2c3e50' : '#e74c3c';
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
            
            renderHealthBar(ctx) {
                const barWidth = this.width;
                const barHeight = 8;
                const barX = this.x;
                const barY = this.y - 15;
                
                // Fond
                ctx.fillStyle = 'red';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Vie
                ctx.fillStyle = 'green';
                const healthWidth = (this.health / this.maxHealth) * barWidth;
                ctx.fillRect(barX, barY, healthWidth, barHeight);
                
                // Bordure
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
        }
        
        // Variables globales
        let animationManager;
        
        async function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            log('üéÆ Initialisation avec animations multi-frames...');
            
            // Cr√©er le gestionnaire d'animations
            animationManager = new AnimationManager();
            
            // Charger toutes les animations
            await animationManager.loadAllAnimations();
            
            // Cr√©er les joueurs
            players = [
                new AnimatedPlayer(200, 480, 'ninja', true),
                new AnimatedPlayer(1000, 480, 'ninja', false) // Les deux ninjas pour l'instant
            ];
            
            log('‚úÖ Jeu initialis√© avec animations !');
        }
        
        function startGame() {
            if (gameRunning) return;
            
            gameRunning = true;
            log('üöÄ Combat avec animations multi-frames !');
            
            document.querySelector('.start-button').style.display = 'none';
            
            lastTime = 0;
            requestAnimationFrame(gameLoop);
        }
        
        function gameLoop(currentTime) {
            if (!gameRunning) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        function update(deltaTime) {
            for (const player of players) {
                player.update(deltaTime);
            }
            
            // Combat
            const [p1, p2] = players;
            const distance = Math.abs(p1.x - p2.x);
            
            if (distance < 100) {
                if (p1.isAttacking && !p1.hasHit && p1.frameIndex > 1) { // Hit √† partir de la frame 2
                    p2.takeDamage(20);
                    p1.hasHit = true;
                    p2.vx = p2.x > p1.x ? 300 : -300;
                }
                if (p2.isAttacking && !p2.hasHit && p2.frameIndex > 1) {
                    p1.takeDamage(20);
                    p2.hasHit = true;
                    p1.vx = p1.x > p2.x ? 300 : -300;
                }
            }
            
            // Interface
            document.getElementById('p1Health').textContent = Math.round(p1.health);
            document.getElementById('p2Health').textContent = Math.round(p2.health);
            
            // Victoire
            if (p1.health <= 0) {
                endGame('üèÜ Joueur 2 gagne !');
            } else if (p2.health <= 0) {
                endGame('üèÜ Joueur 1 gagne !');
            }
        }
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Arri√®re-plan
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Sol
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 700, canvas.width, 100);
            
            // Plateformes
            ctx.fillStyle = '#654321';
            ctx.fillRect(300, 550, 200, 20);
            ctx.fillRect(700, 400, 200, 20);
            ctx.fillRect(500, 300, 200, 20);
            
            // Joueurs
            for (const player of players) {
                player.render(ctx);
            }
        }
        
        function endGame(message) {
            gameRunning = false;
            log('üéØ ' + message);
            setTimeout(() => {
                alert(message + '\nAppuyez sur R pour rejouer !');
            }, 100);
        }
        
        // √âv√©nements
        window.addEventListener('load', init);
        
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.code === 'KeyR') {
                location.reload();
            } else if (e.code === 'KeyP') {
                gameRunning = !gameRunning;
                if (gameRunning) requestAnimationFrame(gameLoop);
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
    </script>
</body>
</html>